{
  "hash": "08b8a6e775a4da9d862ee6b370978de6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Preamble\n---\n\n<div style=\"float:left\">\n    <h1 style=\"width:450px\">Practical 10: Grouping Data</h1>\n    <h2 style=\"width:450px\">Classification &amp; Clusters</h2>\n:::\n<div style=\"float:right\"><img width=\"100\" src=\"https://github.com/jreades/i2p/raw/master/img/casa_logo.jpg\" />\n\n:::\n\n| Complete | Part 1: Foundations | Part 2: Data | Part 3: Analysis |     |\n| :------- | :------------------ | :----------- | :--------------- | --: |\n| 90% | &#9619;&#9619;&#9619;&#9619;&#9619;&#9619;&#9619;&#9619; | &#9619;&#9619;&#9619;&#9619;&#9619;&#9619; | &#9619;&#9619;&#9619;&#9619;&#9619;&#9617; | 10/10\n\nA common challenge in data analysis is how to group observations in a data set together in a way that allows for generalisation: _this_ group of observations are similar to one another, _that_ group is dissimilar to this group. But what defines similarity and difference? There is no _one_ answer to that question and so there are many different ways to cluster data, each of which has strengths and weaknesses that make them more, or less, appropriate in different contexts.\n\n::: {.callout-note}\n\n    **&#128279; Connections**: \n:::\n\n\n\n```python\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport requests\nimport zipfile\nimport re\nimport os\nimport pickle as pk\n\nfrom io import BytesIO, StringIO\nfrom os.path import join as pj\nfrom pathlib import Path\nimport matplotlib as mpl\nfrom matplotlib.colors import ListedColormap\n\nimport sklearn\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.manifold import TSNE\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import PowerTransformer, RobustScaler, StandardScaler\nfrom sklearn.cluster import KMeans, DBSCAN, OPTICS\nfrom esda.adbscan import ADBSCAN\n\nimport random\nrandom.seed(42)    # For reproducibility\nnp.random.seed(42) # For reproducibility\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))\n```\n\n## Load GeoData for Display\n\n```python\n# Load Water GeoPackage\nw_path = os.path.join('data','geo','Water.gpkg')\nif not os.path.exists(w_path):\n    water = gpd.read_file('https://github.com/jreades/i2p/blob/master/data/src/Water.gpkg?raw=true')\n    water.to_file(w_path)\n    print(\"Downloaded Water.gpkg file.\")\nelse:\n    water = gpd.read_file(w_path)\n\n# Boroughs GeoPackage\nb_path = os.path.join('data','geo','Boroughs.gpkg')\nif not os.path.exists(b_path):\n    boroughs = gpd.read_file('https://github.com/jreades/i2p/blob/master/data/src/Boroughs.gpkg?raw=true')\n    boroughs.to_file(b_path)\n    print(\"Downloaded Boroughs.gpkg file.\")\nelse:\n    boroughs = gpd.read_file(b_path)\n```\n\n#### Useful Functions for Plotting\n\n```python\ndef plt_ldn(w=water, b=boroughs):\n    fig, ax = plt.subplots(1, figsize=(14, 12))\n    w.plot(ax=ax, color='#79aef5', zorder=2)\n    b.plot(ax=ax, edgecolor='#cc2d2d', facecolor='None', zorder=3)\n    ax.set_xlim([502000,563000])\n    ax.set_ylim([155000,201500])\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    return fig, ax\n\ndef default_cmap(n, outliers=False):\n    cmap = mpl.cm.get_cmap('viridis_r', n)\n    colors = cmap(np.linspace(0,1,n))\n    if outliers:\n        gray = np.array([225/256, 225/256, 225/256, 1])\n        colors = np.insert(colors, 0, gray, axis=0)\n    return ListedColormap(colors)\n\n# mappable = ax.collections[-1] if you add the geopandas\n# plot last.\ndef add_colorbar(mappable, ax, cmap, norm, breaks, outliers=False):\n    cb = fig.colorbar(mappable, ax=ax, cmap=cmap, norm=norm,\n                    boundaries=breaks,\n                    extend=('min' if outliers else 'neither'), \n                    spacing='uniform',\n                    orientation='horizontal',\n                    fraction=0.05, shrink=0.5, pad=0.05)\n    cb.set_label(\"Cluster Number\")\n```\n\n## Loading Data\n\n#### Load the Listings Data\n\nFeel free to download this manually and load it locally rather that loading via the URL:\n\n```python\nfdf = pd.read_csv(url, compression='gzip', low_memory=False)\n```\n\n```python\nfdf.columns\n```\n\n```python\nfdf[fdf.host_listings_count == 0][['host_total_listings_count','calculated_host_listings_count']]\n```\n\n```python\nurl = 'https://github.com/jreades/i2p/blob/master/data/clean/2020-08-24-listings.csv.gz?raw=true'\ndf = pd.read_csv(url, compression='gzip', low_memory=False, \n                 usecols=['room_type','calculated_host_listings_count','availability_90','availability_365','longitude','latitude','price'])\nprint(f\"Data frame is {df.shape[0]:,} x {df.shape[1]}\")\n```\n\nYou should have: `Data frame is 74,120 x 7`.\n\n#### Aggregating Listings by MSOA\n\nNext, let's link all this using the MSOA Geography that we created last week and a mix or merge and sjoin!\n\n```python\nmsoas = gpd.read_file(os.path.join('data','geo','London_MSOAs.gpkg'), driver='GPKG')\n```\n\n```python\ngdf = gpd.GeoDataFrame(df, \n      geometry=gpd.points_from_xy(df['longitude'], df['latitude'], crs='epsg:4326'))\ngdf = gdf.to_crs('epsg:27700')\n```\n\n```python\n# ml == MSOA Listings\nml = gpd.sjoin(gdf, msoas[['MSOA11CD','geometry']], op='within').drop(columns=\n    ['latitude','longitude','index_right','geometry']\n)\nml = ml[~(ml.room_type.isin(['Hotel room','Shared room']))]\nml.head()\n```\n\n```python\nax = ml.calculated_host_listings_count.hist(bins=1500)\nax.set_xlim([0,50]);\n```\n\n```python\nml['multihost'] = False\nml.loc[ml.calculated_host_listings_count>=3,'multihost'] = True\n```\n\n```python\nax = ml.price.hist(bins=5000)\nax.set_xlim([0,1000]);\n```\n\n```python\nfor p in range(300, 1050, 50):\n    print(f\"Percent of listings above ${p:,}/night: {(ml[ml.price > p].price.count() / ml.shape[0])*100:0.2f}\")\n```\n\n```python\nmlg = ml[ml.price <= 700].groupby(\n    ['MSOA11CD','room_type','multihost'] \n)['price'].agg(Mean='mean', Count='count').reset_index()\nmlg.head()\n```\n\n```python\nrs = RobustScaler(quantile_range=[2.5,97.5])\n```\n\nYou should see wide ranges of counts by roomt type in the first MSOA alone: the largest number of listings is for Entire home/apt but there are 242 multi-host listings compared to 'just' 156 non-multis. I believe this is the City of London though, which is quite unusual for a MSOA and should probably be treated as an outlier in most cases.\n\n```python\nmlgp = mlg.pivot(index='MSOA11CD', columns=['room_type','multihost'], values=['Mean','Count']).reset_index().fillna(0)\nmlgp.head()\n```\n\n```python\nmlgp[['Mean']].head()\n```\n\n```python\nfor c in mlgp[['Mean']].columns.values:\n    mlgp[c] = rs.fit_transform(mlgp[c].values.reshape(-1,1))\n```\n\n```python\nmlgp[['Mean']].head()\n```\n\n```python\nmlgp[['Count']].head()\n```\n\n```python\ntotal = mlgp[['Count']].sum(axis=1)\n```\n\n```python\nfor c in mlgp[['Count']].columns.values:\n    mlgp[c] = rs.fit_transform( (mlgp[c]/total).values.reshape(-1,1) )\n\nmlgp[['Count']].head()\n```\n\n```python\ncols = []\nfor c in mlgp.columns.values:\n    l0 = c[0]\n    l1 = c[1]\n    l2 = \"Multi-host\" if c[2] else \"Single host\"\n    \n    colname = \"\"\n    \n    if l0=='MSOA11CD':\n        cols.append(l0)\n    elif l0=='Mean':\n        cols.append(f\"{l1} {l2} Mean\")\n    elif l0=='Count':\n        cols.append(f\"{l1} {l2} Listings\")\n    else:\n        raise Exception(\"Sorry, please specify how to handle this column\")\n\nprint(cols)\nmlgp.columns = cols\nmlgp.set_index('MSOA11CD', inplace=True)\nmlgp.head()\n```\n\n## PCA\n\n```python\nfrom sklearn.decomposition import PCA \n\nmax_components = mlgp.shape[0] if mlgp.shape[0] < mlgp.shape[1] else mlgp.shape[1]\n\npca = PCA(n_components=max_components, whiten=True) \n\npca.fit(mlgp)\n\nexplained_variance = pca.explained_variance_ratio_\nsingular_values = pca.singular_values_\n```\n\n```python\nx = np.arange(1,len(explained_variance)+1)\nplt.plot(x, explained_variance)\nplt.ylabel('Share of Variance Explained')\nplt.show()\n```\n\n```python\nfor i in range(0, len(explained_variance)):\n    print(f\"Component {i+1:>2} accounts for {explained_variance[i]*100:>2.2f}% of variance\")\n```\n\n```python\nkeep_n_components = 6\n\n# If we weren't changing the number of components we\n# could re-use the pca object created above. \npca = PCA(n_components=keep_n_components, whiten=True)\n\nX_train = pca.fit_transform(mlgp)\n```\n\n```python\nmlgpca = pd.DataFrame(index=mlgp.index)\n\nfor i in range(0,len(X_train.T)):\n    mlgpca[f\"Component {i+1}\"] = X_train.T[i]\n```\n\n```python\nmlgpca.sample(3)\n```\n\n## Clustering Data Frame\n\n```python\ncldf = mlgpca.copy()\n```\n\n```python\ncols_to_plot = np.random.choice(cldf.columns.values, 3, replace=False)\nprint(\"Plotting cols: \" + \", \".join(cols_to_plot))\nrs = cldf.copy()\n```\n\n```python\nc_nm   = 'KMeans' # Clustering name\nk_pref = 4 # Number of clusters\n\nkmeans = KMeans(n_clusters=k_pref, n_init=20, random_state=42).fit(cldf) # The process\n\nprint(kmeans.labels_) # The results\n\n# Add it to the data frame\nrs[c_nm] = pd.Series(kmeans.labels_, index=cldf.index) \n\n# How are the clusters distributed?\nrs[c_nm].hist(bins=k_pref)\n\n# Going to be a bit hard to read if \n# we plot every variable against every\n# other variables, so we'll just pick a few\nsns.set(style=\"white\")\nsns.pairplot(rs, \n             vars=cols_to_plot, \n             hue=c_nm, markers=\".\", height=3, diag_kind='kde')\n```\n\n```python\ncgdf = pd.merge(msoas, rs, on='MSOA11CD')\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results (k={k_pref})\", fontsize=20, y=0.92)\ncgdf.plot(column=c_nm, ax=ax, linewidth=0, zorder=0, categorical=True, legend=True)\n\ndel(cgdf)\n```\n\nOne More Thing...\n\nThere's just one little problem: what assumption did I make when I started this k-means cluster analysis? It's a huge one, and it's one of the reasons that k-means clustering can be problematic when used naively...\n\nSTOP. What critical assumption did we make when running this analysis?\nThe 'Right' Number of Clusters\nAgain, there's more than one way to skin this cat. In Geocomputation they use WCSS to pick the 'optimal' number of clusters. The idea is that you plot the average WCSS for each number of possible clusters in the range of interest (2...n) and then look for a 'knee' (i.e. kink) in the curve. The principle of this approach is that you look for the point where there is declining benefit from adding more clusters. The problem is that there is always some benefit to adding more clusters (the perfect clustering is k==n), so you don't always see a knee.\n\nAnother way to try to make the process of selecting the number of clusters a little less arbitrary is called the silhouette plot and (like WCSS) it allows us to evaluate the 'quality' of the clustering outcome by examining the distance between each observation and the rest of the cluster. In this case it's based on Partitioning Around the Medoid (PAM).\n\nEither way, to evaluate this in a systematic way, we want to do multiple k-means clusterings for multiple values of k and then we can look at which gives the best results...\n\nLet's try it for a range of values...\n\n```python\n# Adapted from: http://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html\nfrom sklearn.metrics import silhouette_samples, silhouette_score\n\ntext = []\n\nfor k in range(2,16):\n    # Debugging\n    print(\"Cluster count: \" + str(k))\n    \n    #############\n    # Do the clustering using the main columns\n    clusterer = KMeans(n_clusters=k, n_init=20, random_state=42)\n    cluster_labels = clusterer.fit_predict(cldf)\n    \n    # Calculate the overall silhouette score\n    silhouette_avg = silhouette_score(cldf, cluster_labels)\n    text = text + [f\"For k={k} the average silhouette_score is: {silhouette_avg:6.4f}\"]\n    \n    # Calculate the silhouette values\n    sample_silhouette_values = silhouette_samples(cldf, cluster_labels)\n    \n    #############\n    # Create a subplot with 1 row and 2 columns\n    fig, (ax1, ax2) = plt.subplots(1, 2)\n    fig.set_size_inches(9, 5)\n\n    # The 1st subplot is the silhouette plot\n    # The silhouette coefficient can range from -1, 1\n    ax1.set_xlim([-1.0, 1.0]) # Changed from -0.1, 1\n    \n    # The (n_clusters+1)*10 is for inserting blank space between silhouette\n    # plots of individual clusters, to demarcate them clearly.\n    ax1.set_ylim([0, cldf.shape[0] + (k + 1) * 10])\n    \n    y_lower = 10\n    \n    # For each of the clusters...\n    for i in range(k):\n        # Aggregate the silhouette scores for samples belonging to\n        # cluster i, and sort them\n        ith_cluster_silhouette_values = \\\n            sample_silhouette_values[cluster_labels == i]\n\n        ith_cluster_silhouette_values.sort()\n\n        size_cluster_i = ith_cluster_silhouette_values.shape[0]\n        y_upper = y_lower + size_cluster_i\n        \n        # Set the color ramp\n        #cmap  = cm.get_cmap(\"Spectral\")\n        color = plt.cm.Spectral(i/k)\n        ax1.fill_betweenx(np.arange(y_lower, y_upper),\n                          0, ith_cluster_silhouette_values,\n                          facecolor=color, edgecolor=color, alpha=0.7)\n\n        # Label the silhouette plots with their cluster numbers at the middle\n        ax1.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))\n\n        # Compute the new y_lower for next plot\n        y_lower = y_upper + 10  # 10 for the 0 samples\n\n    ax1.set_title(\"The silhouette plot for the clusters.\")\n    ax1.set_xlabel(\"The silhouette coefficient values\")\n    ax1.set_ylabel(\"Cluster label\")\n\n    # The vertical line for average silhouette score of all the values\n    ax1.axvline(x=silhouette_avg, color=\"red\", linestyle=\"--\")\n\n    ax1.set_yticks([])  # Clear the yaxis labels / ticks\n    ax1.set_xticks(np.arange(-1.0, 1.1, 0.2)) # Was: [-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1]\n\n    # 2nd Plot showing the actual clusters formed --\n    # we can only do this for the first two dimensions\n    # so we may not see fully what is causing the \n    # resulting assignment\n    colors = plt.cm.Spectral(cluster_labels.astype(float) / k)\n    ax2.scatter(cldf[cldf.columns[0]], cldf[cldf.columns[1]], marker='.', s=30, lw=0, alpha=0.7,\n                c=colors)\n\n    # Labeling the clusters\n    centers = clusterer.cluster_centers_\n    \n    # Draw white circles at cluster centers\n    ax2.scatter(centers[:, 0], centers[:, 1],\n                marker='o', c=\"white\", alpha=1, s=200)\n\n    for i, c in enumerate(centers):\n        ax2.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50)\n\n    ax2.set_title(\"Visualization of the clustered data\")\n    ax2.set_xlabel(\"Feature space for the 1st feature\")\n    ax2.set_ylabel(\"Feature space for the 2nd feature\")\n\n    plt.suptitle((\"Silhouette analysis for KMeans clustering on sample data \"\n                  \"with n_clusters = %d\" % k),\n                 fontsize=14, fontweight='bold')\n\n    plt.show()\n\nprint(\"\\n\".join(text))\n```\n\nInterpreting the Results\n\nSTOP. Make sure that you understand how the silhouette plot and value work, and why your results may diverge from mine.\n\nWe can use the largest average silhouette score to determine the 'natural' number of clusters in the data, but that that's only if we don't have any kind of underlying theory, other empirical evidence, or even just a reason for choosing a different value... Again, we're now getting in areas where your judgement and your ability to communicate your rationale to readers is the key thing.\n\n```python\nc_nm   = 'KMeans'\nk_pref = 7\nkmeans = KMeans(n_clusters=k_pref, n_init=75, random_state=42).fit(cldf)\n\n# Convert to a series\ns = pd.Series(kmeans.labels_, index=cldf.index, name=c_nm)\n\n# We do this for plotting\nrs[c_nm] = s\n```\n\n```python\ncgdf = pd.merge(msoas, rs, on='MSOA11CD')\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results (k={k_pref})\", fontsize=20, y=0.92)\ncgdf.plot(column=c_nm, ax=ax, linewidth=0, zorder=0, categorical=True, legend=True)\n\ndel(cgdf)\n```\n\n\n'Representative' Centroids\nTo get a sense of how these clusters differ we can try to extract 'representative' centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). In the case of k-means this will work quite will since the clusters are explicitly built around mean centroids. There's also a k-medoids clustering approach built around the median centroid.\n\n```python\ncentroids = None\nfor k in sorted(rs[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n\n    clmsoas = rs[rs[c_nm]==k]\n    if centroids is None:\n        centroids = pd.DataFrame(columns=clmsoas.columns.values)\n    centroids = centroids.append(clmsoas.mean(), ignore_index=True)\n\nodf = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    c_index = list(centroids.columns.values).index(c_nm)\n    for c in range(0,c_index):\n        d = {'Variable':centroids.columns[c], 'Cluster':row[c_index], 'Std. Value':row[c]}\n        odf = odf.append(d, ignore_index=True)\n\ng = sns.FacetGrid(odf, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.plot, \"Cluster\", \"Std. Value\", marker=\".\")\n```\n\nDBScan\n\nOf course, as we've said above k-means is just one way of clustering, DBScan is another. Unlike k-means, we don't need to specify the number of clusters in advance. Which sounds great, but we still need to specify other parameters (typically, these are known as hyperparameters because they are about specifying parameters that help the aglorithm to find the right solution... or final set of parameters!) and these can have a huge impact on our results!\n\n\nFind a Reasonable Value for Epsilon\n\nBefore we an use DBSCAN it's useful to find a good value for Epsilon. We can look for the point of maximum 'curvature' in a nearest neigbhours plot. Which seems to be in the vicinity of 0.55. Tips on selecting min_pts can be found here.\n\n```python\nneigh = NearestNeighbors(n_neighbors=2)\nnbrs = neigh.fit(cldf)\ndistances, indices = nbrs.kneighbors(cldf)\n\ndistances = np.sort(distances, axis=0)\ndistances = distances[:,1]\nplt.plot(distances);\n```\n\n```python\nc_nm = 'DBSCAN'\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.4f}'.format(x))\n\nel  = []\n\nmax_clusters  = 10\ncluster_count = 1\n\niters = 0\n\nfor e in np.arange(0.5, 2.5, 0.01):\n    \n    if iters % 25==0: print(f\"{iters} epsilons explored.\") \n    \n    # Run the clustering\n    dbs = DBSCAN(eps=e, min_samples=cldf.shape[1]+1).fit(cldf.values)\n    \n    # See how we did\n    s = pd.Series(dbs.labels_, index=cldf.index, name=c_nm)\n    \n    row = [e]\n    data = s.value_counts()\n    \n    for c in range(-1, max_clusters+1):\n        try:\n            if np.isnan(data[c]):\n                row.append(None)\n            else: \n                row.append(data[c])\n        except KeyError:\n            row.append(None)\n    \n    el.append(row)\n    iters+=1\n\nedf = pd.DataFrame(el, columns=['Epsilon']+[\"Cluster \" + str(x) for x in list(range(-1,max_clusters+1))])\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))\n\nprint(\"Done.\")\n```\n\n```python\nodf = pd.DataFrame(columns=['Epsilon','Cluster','Count'])\n\nfor i in range(0,len(edf.index)):\n    row = edf.iloc[i,:]\n    for c in range(1,len(edf.columns.values)):\n        if row[c] != None and not np.isnan(row[c]):\n            d = {'Epsilon':row[0], 'Cluster':f\"Cluster {c-2}\", 'Count':row[c]}\n            odf = odf.append(d, ignore_index=True)\n```\n\n```python\nodf['Count'] = odf.Count.astype(float)\n```\n\n```python\nxmin = odf[odf.Cluster=='Cluster 0'].Epsilon.min()\nxmax = odf[(odf.Cluster=='Cluster -1') & (odf.Count < cldf.shape[0]/5)].Epsilon.min()\n\nfig, ax = plt.subplots(figsize=(12,8))\nax.set_xlim([xmin,xmax])\nsns.lineplot(data=odf, x='Epsilon', y='Count', hue='Cluster');\n```\n\n```python\ne = 0.835\ndbs = DBSCAN(eps=e, min_samples=cldf.shape[1]+1).fit(cldf.values)\ns = pd.Series(dbs.labels_, index=cldf.index, name=c_nm)\nrs[c_nm] = s\nprint(s.value_counts())\n```\n\n```python\ncgdf = pd.merge(msoas, rs, on='MSOA11CD')\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results\", fontsize=20, y=0.92)\n\ncgdf.plot(column=c_nm, ax=ax, linewidth=0, zorder=0, legend=True, categorical=True)\n\ndel(cgdf)\n```\n\n```python\nfrom sompy.sompy import SOMFactory\n```\n\n```python\ncldf.columns.values\n```\n\n```python\nc_nm = 'SOM'\n\nsm = SOMFactory().build(\n    cldf.values, mapsize=(10,15),\n    normalization='var', initialization='random', component_names=cldf.columns.values)\nsm.train(n_job=4, verbose=False, train_rough_len=2, train_finetune_len=5)\n```\n\n```python\ntopographic_error  = sm.calculate_topographic_error()\nquantization_error = np.mean(sm._bmu[1])\nprint(\"Topographic error = {0:0.5f}; Quantization error = {1:0.5f}\".format(topographic_error, quantization_error))\n```\n\n```python\nfrom sompy.visualization.mapview import View2D\nview2D = View2D(10, 10, \"rand data\", text_size=10)\nview2D.show(sm, col_sz=4, which_dim=\"all\", denormalize=True)\n```\n\n```python\nfrom sompy.visualization.bmuhits import BmuHitsView\nvhts = BmuHitsView(15, 15, \"Hits Map\", text_size=8)\nvhts.show(sm, anotate=True, onlyzeros=False, labelsize=9, cmap=\"plasma\", logaritmic=False)\n```\n\n```python\nfrom sompy.visualization.hitmap import HitMapView\n\nk_val = 5\nsm.cluster(k_val)\nhits  = HitMapView(15, 15, \"Clustering\", text_size=14)\na     = hits.show(sm)\n```\n\n```python\n# Get the labels for each BMU\n# in the SOM (15 * 10 neurons)\nclabs = sm.cluster_labels\n\n# Project the data on to the SOM\n# so that we get the BMU for each\n# of the original data points\nbmus  = sm.project_data(cldf.values)\n\n# Turn the BMUs into cluster labels\n# and append to the data frame\ns = pd.Series(clabs[bmus], index=rs.index, name=c_nm)\n\nrs[c_nm] = s\n```\n\n```python\ncgdf = pd.merge(msoas, rs, on='MSOA11CD')\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results\", fontsize=20, y=0.92)\n\ncgdf.plot(column=c_nm, ax=ax, linewidth=0, zorder=0, legend=True, categorical=True)\n\ndel(cgdf)\n```\n\n```python\ncentroids = None\nfor k in sorted(rs[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n\n    clsoas = rs[rs[c_nm]==k]\n    if centroids is None:\n        centroids = pd.DataFrame(columns=clsoas.columns.values)\n    centroids = centroids.append(clsoas.mean(), ignore_index=True)\n\nodf = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    c_index = list(centroids.columns.values).index(c_nm)\n    for c in range(0,c_index):\n        d = {'Variable':centroids.columns[c], 'Cluster':row[c_index], 'Std. Value':row[c]}\n        odf = odf.append(d, ignore_index=True)\n\ng = sns.FacetGrid(odf, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.plot, \"Cluster\", \"Std. Value\", marker=\".\")\n\ndel(odf, centroids)\n```\n\n\n\n\n### Which Clustering Approach is Right?\n\nThe reason that there is no 'right' approach to clustering is that it all depends on what you're trying to accomplish and how you're _reasoning_ about your problem. The image below highlights the extent to which the different clustering approaches in sklearn can produce different results -- and this is only for the _non-geographic_ algorithms!\n\n<a href=\"http://scikit-learn.org/stable/modules/clustering.html#clustering\"><img alt=\"Clustering algorithm comparison\" src=\"http://scikit-learn.org/stable/_images/sphx_glr_plot_cluster_comparison_0011.png\" width=\"700px\" /></a>\n\n_Note:_ for geographically-aware clustering you need to look at PySAL.\n\nTo think about this in a little more detail:\n\n* If I run an online company and I want to classify my customers on the basis of their product purchases, then I probably don't care much about where they are, only about what they buy, and so my clustering approach doesn't need to take geography into account. I might well _discover_ that many of my most valuable customers live in a few areas, but that is a finding, not a factor, in my research.\n* Conversely, if I am looking for cancer clusters then I might well care a _lot_ about geography because I want to make sure that I don't overlook an important cluster of cases because it's 'hidden' inside an area with lots of people who don't have cancer. In that case, I want my clusters to take geography into account. That approach might classify an area with a smaller proportion of cancer patients as part of a 'cancer cluster' but that's because it is still significant _because_ of the geography.\n\nSo you can undertake a spatial analysis using _either_ approach, it just depends on the role that you think geography should play in producing the clusters in the first place. We'll see this in action today!\n\n#### Ensure Plotting Output\n\n```python\nimport matplotlib as mpl\nmpl.use('TkAgg')\n%matplotlib inline\n```\n\n#### Importing the Libraries\n\n```python\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport requests\nimport zipfile\nimport re\nimport os\nimport pickle as pk\n\nfrom io import BytesIO, StringIO\nfrom os.path import join as pj\nfrom pathlib import Path\nimport matplotlib as mpl\nfrom matplotlib.colors import ListedColormap\n\nimport sklearn\nsklv = int(sklearn.__version__.replace(\".\",\"\"))\nif sklv < 210:\n    print(\"SciKit-Learn verion is: \" + sklearn.__version__)\n    print(\"The OPTICS part of this notebook relies on a version >= 0.21.0\")\n\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.manifold import TSNE\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import PowerTransformer\nfrom sklearn import preprocessing\nfrom sklearn import cluster\n\nimport random\nrandom.seed(42)    # For reproducibility\nnp.random.seed(42) # For reproducibility\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))\n```\n\n```python\nsrc = 'https://github.com/kingsgeocomp/applied_gsa/blob/master/data/Census.zip?raw=true'\ndst = os.path.join('analysis','Census.zip')\n\nif not os.path.exists(dst):\n    if not os.path.exists(os.path.dirname(dst)):\n        os.makedirs(os.path.dirname(dst))\n    \n    print(\"Downloading...\")\n    r = requests.get(src, stream=True)\n    \n    with open(dst, 'wb') as fd:\n        for chunk in r.iter_content(chunk_size=128):\n            fd.write(chunk)\nelse:\n    print(\"File already downloaded.\")\n    \nprint(\"Done.\")\n```\n\n### Loading the NomisWeb Data\n\nYou may need to make a few adjustments to the path to get the data loaded on your own computer. But notice what we're now able to do here: using the `zipfile` library we can extract a data file (or any other file) from the Zip archive without even having to open it. Saves even more time _and_ disk space!\n\n```python\nz = zipfile.ZipFile(os.path.join('analysis','Census.zip'))\nz.namelist()\n```\n\nWe're going to save each data set to a separate data frame to make it easier to work with during cleaning. But note that this code is fairly flexible since we stick each new dataframe in a dictionary (`d`) where we can retrieve them via an iterator.\n\n```python\nraw   = {}\nclean = {}\ntotal_cols = 0\n\nfor r in range(0, len(z.namelist())):\n    \n    m  = re.search(\"(?:-)([^\\.]+)\", z.namelist()[r])\n    nm = m.group(1)\n    \n    print(\"Processing {0} file: \".format(nm))\n    \n    with z.open(z.namelist()[r]) as f:\n                \n        if z.namelist()[r] == '99521530-Activity.csv': \n            raw[nm] = pd.read_csv(BytesIO(f.read()), header=7, skip_blank_lines=True, skipfooter=7, engine='python')\n        else:\n            raw[nm] = pd.read_csv(BytesIO(f.read()), header=6, skip_blank_lines=True, skipfooter=7, engine='python')\n    \n    print(\"\\tShape of dataframe is {0} rows by {1} columns\".format(raw[nm].shape[0], raw[nm].shape[1]))\n    total_cols += raw[nm].shape[1]\n\nprint(\"There are {0} columns in all.\".format(total_cols))\n```\n\n```python\nnm  = 'Occupation'\nurl = 'https://github.com/jreades/urb-studies-predicting-gentrification/raw/master/data/src/2011/ks610ew.csv.gz'\n\nprint(f\"Processing {nm}\")\ndf = pd.read_csv(url, header=7, skip_blank_lines=True, compression='gzip', low_memory=False)\nmapping = {\n    '1. Managers, directors and senior officials':'Managers',\n    '2. Professional occupations':'Professionals',\n    '3. Associate professional and technical occupations':'Associates',\n    '4. Administrative and secretarial occupations':'Administrative',\n    '5. Skilled trades occupations':'Skilled trades',\n    '6. Caring, leisure and other service occupations':'Caring and Leisure',\n    '7. Sales and customer service occupations':'Customer Service',\n    '8. Process plant and machine operatives':'Operatives',\n    '9. Elementary occupations':'Elementary'\n}\ndf.rename(columns=mapping, inplace=True)\ndf.drop(['2011 super output area - lower layer','All categories: Occupation'], axis=1, inplace=True)\n\nraw[nm] = df\ndf.sample(3, random_state=42)\n```\n\n```python\nnm  = 'Income'\nurl  = 'https://data.london.gov.uk/download/household-income-estimates-small-areas/7c1099d9-327b-4f20-abb8-8c24a3c10c47/modelled-household-income-estimates-lsoa.csv'\n\nprint(f\"Processing {nm}\")\ndf = pd.read_csv(url, encoding='latin-1')[['Code','Median 2011/12']]\ndf['Median Income'] = df['Median 2011/12'].str.replace('£','').str.replace(',','').astype('float')\ndf.drop('Median 2011/12', axis=1, inplace=True)\n\nraw[nm] = df\ndf.sample(3, random_state=42)\n```\n\n```python\nnm  = 'Housing'\nurl = 'https://data.london.gov.uk/download/average-house-prices/9a92fbaf-c04e-498a-9f8c-6c85f280817e/land-registry-house-prices-LSOA.csv'\n\nprint(f\"Processing {nm}\")\ndf = pd.read_csv(url, encoding='latin-1', low_memory=False)\n\ndf['Borough'] = df.Area.str.replace(' [0-9A-Z]{4}$','')\ndf.drop('Area', axis=1, inplace=True)\n\ndf = df[ (df.Year=='Year ending Dec 2011') & (df.Measure=='Median') ][['Code','Value','Borough']]\n\n# Note: not all have a value for this year!\ndf['Median House Price'] = df.Value.str.replace(':','-1').astype(float)\n\nla = df.groupby('Borough')\nla_prices = pd.DataFrame(la['Median House Price'].median())\n\ndf = df.join(la_prices, how='inner', on='Borough', rsuffix='_la')\n\ndf.loc[df['Median House Price'] < 50000,'Median House Price'] =  df[df['Median House Price'] < 50000]['Median House Price_la']\ndf.drop(['Value','Borough','Median House Price_la'], inplace=True, axis=1)\n\nraw[nm] = df\ndf.sample(3, random_state=42)\n```\n\n### ONS Boundary Data\n\nWe also need to download the LSOA boundary data. A quick Google search on \"2011 LSOA boundaries\" will lead you to the [Data.gov.uk portal](https://data.gov.uk/dataset/lower_layer_super_output_area_lsoa_boundaries). The rest is fairly straightforward:\n* We want 'generalised' because that means that they've removed some of the detail from the boundaries so the file will load (and render) more quickly.\n* We want 'clipped' because that means that the boundaries have been clipped to the edges of the land (e.g. the Thames; the 'Full' data set splits the Thames down the middle between adjacent LSOAs).\n\n#### Saving Time\n\nAgain, in order to get you started more quickly I've already created a 'pack' for you. However, note that the format of this is a GeoPackage, this is a fairly new file format designed to replace ESRI's antique Shapefile format, and it allows us to include all kinds of useful information as part of the download as well as doing away with the need to unzip a download first! So here we load the data directly into a geopandas dataframe:\n\n```python\nsrc = 'https://github.com/kingsgeocomp/applied_gsa/raw/master/data/London%20LSOAs.gpkg'\n\ngdf = gpd.read_file(src)\nprint(\"Shape of LSOA file: {0} rows by {1} columns\".format(gdf.shape[0], gdf.shape[1]))\ngdf.columns = [x.lower() for x in gdf.columns.values]\ngdf.set_index('lsoa11cd', drop=True, inplace=True)\ngdf.sample(4)\n```\n\n#### <span style=\"color:red\">Error!</span>\n\nDepending on your version of GDAL/Fiona, you may not be able to read the GeoPackage file directly. In this case you will need to replace the code above with the code below for downloading and extracting a Shapefile from a Zip archive:\n```python\nsrc = 'https://github.com/kingsgeocomp/applied_gsa/blob/master/data/Lower_Layer_Super_Output_Areas_December_2011_Generalised_Clipped__Boundaries_in_England_and_Wales.zip?raw=true'\ndst = os.path.join('analysis','LSOAs.zip')\nzpd = 'analysis'\n\nif not os.path.exists(dst):\n    if not os.path.exists(os.path.dirname(dst)):\n        os.makedirs(os.path.dirname(dst))\n\n    r = requests.get(src, stream=True)\n\n    with open(dst, 'wb') as fd:\n        for chunk in r.iter_content(chunk_size=128):\n            fd.write(chunk)\n\nif not os.path.exists(zpd):\n    os.makedirs(os.path.dirname(zpd))\n    \nzp = zipfile.ZipFile(dst, 'r')\nzp.extractall(zpd)\nzp.close()\n\ngdf = gpd.read_file(os.path.join('analysis','lsoas','Lower_Layer_Super_Output_Areas_December_2011_Generalised_Clipped__Boundaries_in_England_and_Wales.shp'))\ngdf.crs = {'init' :'epsg:27700'}\nprint(\\\"Shape of LSOA file: {0} rows by {1} columns\\\".format(gdf.shape[0], gdf.shape[1]))\ngdf.set_index('lsoa11cd', drop=True, inplace=True)\ngdf.sample(4)\n```\n\nYou can probably see why I'm a big fan of GeoPackages when they're available!\n\n### Other Sources of Data\n\nIf you're more interested in US Census data then there's a nice-looking (though I haven't used it) [wrapper to the Census API](https://pypi.python.org/pypi/census). And [Spielman and Singleton](https://www.tandfonline.com/doi/full/10.1080/00045608.2015.1052335) have done some work on large-scale geodemographic clustering of U.S. Census geographies.\n\n### Direct Downloads\n\nThese are already clean, so we can just copy them over.\n\n```python\nfor t in ['Occupation','Housing','Income']:\n    raw[t].rename(columns={'Code':'mnemonic'}, inplace=True)\n    print(raw[t].columns)\n    clean[t] = raw[t]\n```\n\n### Dwellings\n\nFrom dwellings we're mainly interested in the housing type since we would expect that housing typologies will be a determinant of the types of people who live in an area. We _could_ look at places with no usual residents as well, or explore the distribution of shared dwellings, but this is a pretty good start.\n\n```python\nt = 'Dwellings'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'Whole house or bungalow: Detached', \n    'Whole house or bungalow: Semi-detached',\n    'Whole house or bungalow: Terraced (including end-terrace)',\n    'Flat, maisonette or apartment: Purpose-built block of flats or tenement',\n    'Flat, maisonette or apartment: Part of a converted or shared house (including bed-sits)',\n    'Flat, maisonette or apartment: In a commercial building'\n]\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nmapping = {}\nfor c in selection[1:]:\n    m  = re.search(\"^(?:[^\\:]*)(?:\\:\\s)?([^\\(]+)\", c)\n    nm = m.group(1).strip()\n    #print(\"Renaming '{0}' to '{1}'\".format(c, nm))\n    mapping[c] = nm\n\nclean[t].rename(columns=mapping, inplace=True)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Age\n\nClearly, some areas have more young people, some have older people, and some will be composed of families. A lot of these are going to be tied to 'lifestage' and so will help us to understand something about the types of areas in which they live.\n\n```python\nt = 'Age'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'Age 0 to 14',\n    'Age 15 to 24',\n    'Age 25 to 44',\n    'Age 45 to 64',\n    'Age 65+'\n]\n\n# Derived columns\nraw[t]['Age 0 to 14']  = raw[t]['Age 0 to 4'] + raw[t]['Age 5 to 7'] + raw[t]['Age 8 to 9'] + raw[t]['Age 10 to 14'] \nraw[t]['Age 15 to 24'] = raw[t]['Age 15'] + raw[t]['Age 16 to 17'] + raw[t]['Age 18 to 19'] + raw[t]['Age 20 to 24']\nraw[t]['Age 25 to 44'] = raw[t]['Age 25 to 29'] + raw[t]['Age 30 to 44']\nraw[t]['Age 45 to 64'] = raw[t]['Age 45 to 59'] + raw[t]['Age 60 to 64']\nraw[t]['Age 65+']      = raw[t]['Age 65 to 74'] + raw[t]['Age 75 to 84'] + raw[t]['Age 85 to 89'] + raw[t]['Age 90 and over']\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Ethnicity\n\nWe might also think that the balance of ethnic groups might impact a categorisation of LSOAs in London.\n\n```python\nt = 'Ethnicity'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'White', \n    'Mixed/multiple ethnic groups', \n    'Asian/Asian British', \n    'Black/African/Caribbean/Black British', \n    'Other ethnic group'\n]\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Rooms\n\nLet's next incorporate the amount of space available to each household.\n\n```python\nt = 'Rooms'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'Occupancy rating (bedrooms) of -1 or less',\n    'Occupancy rating (rooms) of -1 or less',\n    'Average household size', \n#    'Average number of bedrooms per household',\n#    'Average number of rooms per household',\n]\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Vehicles\n\nCar ownership and use is also known to be a good predictor of social and economic 'status': Guy Lansley's article on the DLVA's registration database offers a useful perpective on the usefulness of this approach.\n\n```python\nt = 'Vehicles'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'No cars or vans in household', \n    '1 car or van in household',\n    '2 cars or vans in household', \n    '3 or more cars or vans in household'\n]\n\n# Calculate a new column\nraw[t]['3 or more cars or vans in household'] = raw[t]['3 cars or vans in household'] + raw[t]['4 or more cars or vans in household']\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Tenure\n\nOwnership structure is another categorisation predictor.\n\n```python\nt = 'Tenure'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'Owned', \n    'Social rented', \n    'Private rented',\n    'Shared ownership (part owned and part rented)'\n]\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nclean[t].rename(columns={'Shared ownership (part owned and part rented)':'Shared ownership'}, inplace=True)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Qualifications\n\nYou can find out a bit more about qualifications [here](https://www.surreyi.gov.uk/2011-census/highest-level-of-qualification/#header-qualifications-categories).\n\n```python\nt = 'Qualifications'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'Highest level of qualification: Below Level 3 qualifications',\n    'Highest level of qualification: Level 3 and above qualifications',\n    'Highest level of qualification: Other qualifications'\n]\n\n# Derive a new aggregate field for 'didn't complete HS'\nraw[t]['Highest level of qualification: Below Level 3 qualifications'] = \\\n    raw[t]['No qualifications'] + \\\n    raw[t]['Highest level of qualification: Level 1 qualifications'] + \\\n    raw[t]['Highest level of qualification: Level 2 qualifications'] + \\\n    raw[t]['Highest level of qualification: Apprenticeship'] \n\nraw[t]['Highest level of qualification: Level 3 and above qualifications'] = \\\n    raw[t]['Highest level of qualification: Level 3 qualifications'] + \\\n    raw[t]['Highest level of qualification: Level 4 qualifications and above']\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nmapping = {}\nfor c in selection[1:]:\n    m  = re.search(\"^(?:[^\\:]*)(?:\\:\\s)?([^\\(]+)\", c)\n    nm = m.group(1).strip()\n    #print(\"Renaming '{0}' to '{1}'\".format(c, nm))\n    mapping[c] = nm\n\nclean[t].rename(columns=mapping, inplace=True)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Activity\n\n```python\nt = 'Activity'\nraw[t].columns\n```\n\n```python\n# Select the columns we're interested in analysing\nselection = ['mnemonic',\n    'Economically active: In employment',\n    'Economically active: Unemployed',\n    'Economically active: Full-time student',\n#    'Economically inactive: Retired',\n    'Economically inactive: Looking after home or family',\n    'Economically inactive: Long-term sick or disabled',\n#    'Economically inactive: Other'\n]\n\n# Drop everything *not* in the selection\nclean[t] = raw[t].drop(raw[t].columns[~np.isin(raw[t].columns.values,selection)].values, axis=1)\n\nmapping = {}\nfor c in selection[1:]:\n    m  = re.search(\"^(?:[^\\:]*)(?:\\:\\s)?([^\\(]+)\", c)\n    nm = m.group(1).strip()\n    #print(\"Renaming '{0}' to '{1}'\".format(c, nm))\n    mapping[c] = nm\n\nclean[t].rename(columns=mapping, inplace=True)\n\nclean[t].sample(5, random_state=42)\n```\n\n### Standardisation with SKLearn\n\nLet's try standardising the data now:\n\n```python\n# Here's how we can rescale and transform data easily\nfrom sklearn.preprocessing import PowerTransformer\nfrom sklearn.preprocessing import RobustScaler\nfrom sklearn.preprocessing import MinMaxScaler\n```\n\n```python\nrandom.seed(42)\nt   = random.sample(population=list(clean.keys()), k=1)[0]\ncol = random.sample(population=list(clean[t].columns.values[1:]), k=1)[0]\nprint(f\"Looking at {col} column from {t}.\")\n```\n\nHere's the 'original' distribution:\n\n```python\nplt.rcParams['figure.figsize']=(7,3)\nsns.distplot(clean[t][col], kde=False)\n```\n\nHere's the version that has been re-scaled (standardised) using Min/Max rescaling:\n\n```python\nplt.rcParams['figure.figsize']=(7,3)\nsns.distplot(preprocessing.minmax_scale(clean[t][col].values.reshape(-1,1)), kde=False)\n```\n\nHere's a version that has been robustly rescaled:\n\n```python\nplt.rcParams['figure.figsize']=(7,3)\nsns.distplot(preprocessing.robust_scale(clean[t][col].values.reshape(-1,1), quantile_range=[5.0, 95.0]), kde=False)\n```\n\nAnd here's a version that has been Power Transformed... spot the difference!\n\n```python\nsns.distplot(\n    preprocessing.power_transform(clean[t][col].values.reshape(-1,1), method='yeo-johnson'), kde=False)\n```\n\nCombining transformation _and_ rescaling:\n\n```python\nsns.distplot(\n    preprocessing.robust_scale(\n        preprocessing.power_transform(\n            clean[t][col].values.reshape(-1,1), method='yeo-johnson'\n        ), quantile_range=[5.0, 95.0] \n    ), \n    kde=False\n)\n```\n\n```python\n# Set up a new dictionary for the transforms\ntransformed = {}\n\ntransformer = preprocessing.PowerTransformer()\nscaler      = preprocessing.RobustScaler(quantile_range=[5.0, 95.0])\n#scaler      = preprocessing.MinMaxScaler()\n\n# Simple way to drop groups of data we don't want...\nsuppress       = set(['Rooms','Vehicles'])\n\nfor k in set(clean.keys()).difference(suppress):\n    print(f\"Transforming {k}\")\n    df = clean[k].copy(deep=True)\n    df.set_index('mnemonic', inplace=True)\n    \n    # For rescale and transforming everything when the operations\n    # apply to each Series separately you can do it as a 1-liner like this:\n    #df[df.columns] = scaler.fit_transform(transformer.fit_transform(df[df.columns]))\n\n    # To calculate within-*column* proportions it's like this:\n    #for c in df.columns.values: \n    #    df[c] = scaler.fit_transform( (df[c]/df[c].max() ).values.reshape(-1, 1) )\n\n    # To calculate within-*group* proportions it's like this:\n    if k in ['Housing','Income','Rooms']:\n        df[df.columns] = scaler.fit_transform( df[df.columns] )\n    else: \n        df['sum'] = df[list(df.columns)].sum(axis=1)\n        for c in df.columns.values:\n            if c == 'sum':\n                df.drop(['sum'], axis=1, inplace=True)\n            else:\n                df[c] = scaler.fit_transform( (df[c]/df['sum']).values.reshape(-1, 1) )\n            \n    #print(df.sample(5, random_state=42))\n    transformed[k] = df\n```\n\n### Creating the Single Data Set\n\nNow that we've converted everything to percentages, it's time to bring the data together! We'll initialise the data frame using the first matching data set, and then iterate over the rest, merging the data frames as we go.\n\n```python\nmatching = list(transformed.keys())\nprint(\"Found the following data sets:\\n\\t\" + \", \".join(matching))\n\n# Initialise the data frame simply by grabbing the\n# very first existing data frame and copying it \n# directly (SCaled Data Frame == scdf)\nscdf  = transformed[matching[0]].copy() \nlsoac = clean[matching[0]].copy() \n\nfor m in range(1, len(matching)):\n    scdf  = scdf.merge(transformed[matching[m]], how='inner', left_on='mnemonic', right_on='mnemonic')\n    lsoac = lsoac.merge(clean[matching[m]], how='inner', left_on='mnemonic', right_on='mnemonic')\n\nscdf.to_csv(os.path.join('data','Scaled_and_Transformed.csv.gz'), compression='gzip')\nlsoac.to_csv(os.path.join('data','Cleaned.csv.gz'), compression='gzip')\n```\n\n```python\nprint(\"Shape of full data frame is {0} by {1}\".format(scdf.shape[0], scdf.shape[1]))\n```\n\nWith luck you still have 4,835 rows, but now you have rather fewer than 88 columns.\n\n```python\nrandom.seed(42)\ncols_to_plot = random.sample(population=list(scdf.columns.values), k=3)\nprint(\"Columns to plot: \" + \", \".join(cols_to_plot))\n```\n\n```python\n# The data as it is now...\nsns.set(style=\"whitegrid\")\nsns.pairplot(lsoac, \n             vars=cols_to_plot, \n             markers=\".\", height=3, diag_kind='kde')\n```\n\n```python\n# The data as it is now...\nsns.set(style=\"whitegrid\")\nsns.pairplot(scdf, \n             vars=cols_to_plot, \n             markers=\".\", height=3, diag_kind='kde')\n```\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">STOP. Making sure that you understand how and why this results differns from the *same* plot above.\n\n:::\n\nRight, so you can see that rescaling the dimension hasn't *actually* changed the relationships within each dimension, or even between dimensions, but it has changed the overall range so that the the data is broadly re-centered on 0 but we *still* have the original outliers from the raw data. You could _also_ do IQR standardisation (0.25 and 0.75) with the percentages, but in those cases you would have _more_ outliers and then _more_ extreme values skewing the results of the clustering algorithm.\n\n#### Freeing Up Memory\n\nWe now have quite a few variables/datasets in memory, so it's a good idea to free up some RAM by getting rid of anything we no longer need...\n\n```python\nin_scope  = set([x for x in dir() if not x.startswith('_')])\nto_delete = set(['raw','clean','transformed','col','k','c','lsoac','scdf'])\nz = list(in_scope.intersection(to_delete))\ndel(z)\n```\n\n#### Clustering Your Data\n\nOK, we're finally here! It's time to cluster the cleaned, normalised, and standardised data set! We're going to start with the best-known clustering technique (k-means) and work from there... Don't take my word for it, here are the [5 Clustering Techniques Every Data Scientist Should Know](https://towardsdatascience.com/the-5-clustering-algorithms-data-scientists-need-to-know-a36d136ef68). This is also a good point to refer back to some of what we've been doing (and it's a good point to potentially disagree with me!) since [clustering in high dimensions can be problematic](https://towardsdatascience.com/how-to-cluster-in-high-dimensions-4ef693bacc6) (_i.e._ the more dimensions the worse the Euclidean distance gets as a cluster metric).\n\nThe effectiveness of clustering algorithms is usually demonstrated using the 'iris data' -- it's available by default with both Seaborn and SciKit-Learn. This data doesn't usually need normalisation but it's a good way to start looking at the data across four dimensions and seeing how it varies and why some dimensions are 'good' for clustering, while others are 'not useful'...\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">Unfortunately, our data is a *lot* messier and has many more dimensions (>25) than this.\n\n:::\n\n\n\n- Find the appropriate eps value: [Nearest Neighbour Distance Functions](https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Nearest-Neighbor-Distance-Functions)\n\n#### Brief Discussion\n\nIn the practical I've followed the _Geocomputation_ approach of basically converting everything to a share (percentage) and then clustering on that. This is _one_ way to approach this problem, but there are _many_ others. For instance, many people might skip the percentages part and apply robust rescaling ([`sklearn.preprocessing.RobustScaler`](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.RobustScaler.html)) using centering and quantile standardisation (the 5th and 95th, for example) instead. And possibly using a normalising transformation (such as a [Power Transform](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.PowerTransformer.html)) as well. \n\nI would also consider using PCA on groups of related variables (_e.g._ the housing features as a group, the ethnicity features as a group, etc.) and then take the first few eigenvalues from each group and cluster on all of those together. This would remove quite a bit of the correlation between variables and still allow us to perform hierarchical and other types of clustering on the result. It might also do a better job of preserving outliers.\n\n\n\n#### Create an Output Directory and Load the Data\n\n```python\no_dir = os.path.join('outputs','clusters')\nif os.path.isdir(o_dir) is not True:\n    print(\"Creating '{0}' directory.\".format(o_dir))\n    os.makedirs(o_dir)\n```\n\n```python\ndf = pd.read_csv(os.path.join('data','Scaled_and_Transformed.csv.gz'))\ndf.rename(columns={'mnemonic':'lsoacd'}, inplace=True)\ndf.set_index('lsoacd', inplace=True)\ndf.describe()\n```\n\n```python\ndf.sample(3, random_state=42)\n```\n\n#### Grab Borough Boundaries and Water Courses\n\n_Note:_ if reading these GeoPackages gives you errors then you will need to comment out the following two lines from the `plt_ldn` function immediately below:\n```python\n    w.plot(ax=ax, color='#79aef5', zorder=2)\n    b.plot(ax=ax, edgecolor='#cc2d2d', facecolor='None', zorder=3)\n```\n\n```python\n# Load Water GeoPackage\nw_path = os.path.join('data','Water.gpkg')\nif not os.path.exists(w_path):\n    water = gpd.read_file('https://github.com/kingsgeocomp/applied_gsa/raw/master/data/Water.gpkg')\n    water.to_file(w_path)\n    print(\"Downloaded Water.gpkg file.\")\nelse:\n    water = gpd.read_file(w_path)\n\n# Boroughs GeoPackage\nb_path = os.path.join('data','Boroughs.gpkg')\nif not os.path.exists(b_path):\n    boroughs = gpd.read_file('https://github.com/kingsgeocomp/applied_gsa/raw/master/data/Boroughs.gpkg')\n    boroughs.to_file(b_path)\n    print(\"Downloaded Boroughs.gpkg file.\")\nelse:\n    boroughs = gpd.read_file(b_path)\n```\n\n#### Useful Functions for Plotting\n\n```python\ndef plt_ldn(w=water, b=boroughs):\n    fig, ax = plt.subplots(1, figsize=(14, 12))\n    w.plot(ax=ax, color='#79aef5', zorder=2)\n    b.plot(ax=ax, edgecolor='#cc2d2d', facecolor='None', zorder=3)\n    ax.set_xlim([502000,563000])\n    ax.set_ylim([155000,201500])\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    return fig, ax\n\ndef default_cmap(n, outliers=False):\n    cmap = mpl.cm.get_cmap('viridis_r', n)\n    colors = cmap(np.linspace(0,1,n))\n    if outliers:\n        gray = np.array([225/256, 225/256, 225/256, 1])\n        colors = np.insert(colors, 0, gray, axis=0)\n    return ListedColormap(colors)\n\n# mappable = ax.collections[-1] if you add the geopandas\n# plot last.\ndef add_colorbar(mappable, ax, cmap, norm, breaks, outliers=False):\n    cb = fig.colorbar(mappable, ax=ax, cmap=cmap, norm=norm,\n                    boundaries=breaks,\n                    extend=('min' if outliers else 'neither'), \n                    spacing='uniform',\n                    orientation='horizontal',\n                    fraction=0.05, shrink=0.5, pad=0.05)\n    cb.set_label(\"Cluster Number\")\n```\n\n#### Select 4 Columns to Plot\n\n```python\nrandom.seed(42)\ncols_to_plot = random.sample(population=list(df.columns.values), k=4)\nprint(\"Columns to plot: \" + \", \".join(cols_to_plot))\n```\n\n#### Storing Results\n\n```python\nresult_set = None\n\ndef add_2_rs(s, rs=result_set):\n    if rs is None:\n        # Initialise\n        rs = pd.DataFrame()\n    rs[s.name] = s\n    return rs\n```\n\n### K-Means\n\n#### Importing the Library\n\n```python\nfrom sklearn.cluster import KMeans\n#help(KMeans)\n```\n\nThe next few code blocks may take a while to complete, largely because of the `pairplot` at the end where we ask Seaborn to plot every dimension against every other dimension _while_ colouring the points according to their cluster. I've reduced the plotting to just three dimensions, if you want to plot all of them, then just replace the array attached to `vars` with `main_cols`, but you have to bear in mind that that is plotting 4,300 points _each_ time it draws a plot... and there are 81 of them! It'll take a while, but it _will_ do it, and try doing that in Excel or SPSS?\n\n#### A First Cluster Analysis\n\n```python\nc_nm   = 'KMeans' # Clustering name\nk_pref = 6 # Number of clusters\n\n# Quick sanity check in case something hasn't\n# run successfully -- these muck up k-means\ncldf = df.drop(list(df.columns[df.isnull().any().values].values), axis=1)\n\nkmeans = KMeans(n_clusters=k_pref, n_init=20, random_state=42, n_jobs=-1).fit(cldf) # The process\n\nprint(kmeans.labels_) # The results\n\n# Add it to the data frame\ncldf[c_nm] = pd.Series(kmeans.labels_, index=df.index) \n\n# How are the clusters distributed?\ncldf[c_nm].hist(bins=k_pref)\n\n# Going to be a bit hard to read if \n# we plot every variable against every\n# other variables, so we'll just pick a few\nsns.set(style=\"white\")\nsns.pairplot(cldf, \n             vars=cols_to_plot, \n             hue=c_nm, markers=\".\", height=3, diag_kind='kde')\n```\n\n```python\ncgdf = gdf.join(cldf, how='inner')\n\nbreaks = np.arange(0,cldf[c_nm].max()+2,1)\ncmap   = default_cmap(len(breaks))\n\nnorm    = mpl.colors.BoundaryNorm(breaks, cmap.N)\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results (k={k_pref})\", fontsize=20, y=0.92)\ncgdf.plot(column=c_nm, ax=ax, cmap=cmap, norm=norm, linewidth=0, zorder=0)\n\nadd_colorbar(ax.collections[-1], ax, cmap, norm, breaks)\n\ndel(cgdf)\n```\n\n#### One More Thing...\n\nThere's just _one_ little problem: what assumption did I make when I started this *k*-means cluster analysis? It's a huge one, and it's one of the reasons that *k*-means clustering _can_ be problematic when used naively...\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">STOP. What critical assumption did we make when running this analysis?\n\n:::\n\n#### The 'Right' Number of Clusters\n\nAgain, there's more than one way to skin this cat. In _Geocomputation_ they use WCSS to pick the 'optimal' number of clusters. The idea is that you plot the average WCSS for each number of possible clusters in the range of interest (`2...n`) and then look for a 'knee' (i.e. kink) in the curve. The principle of this approach is that you look for the point where there is declining benefit from adding more clusters. The problem is that there is always _some_ benefit to adding more clusters (the perfect clustering is _k==n_), so you don't always see a knee. \n\nAnother way to try to make the process of selecting the number of clusters a little less arbitrary is called the silhouette plot and (like WCSS) it allows us to evaluate the 'quality' of the clustering outcome by examining the distance between each observation and the rest of the cluster. In this case it's based on Partitioning Around the Medoid (PAM). \n\nEither way, to evaluate this in a systematic way, we want to do _multiple_ _k_-means clusterings for _multiple_ values of _k_ and then we can look at which gives the best results...\n\nLet's try it for the range 3-9.\n\n```python\n# Adapted from: http://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html\nfrom sklearn.cluster import KMeans\nfrom sklearn.metrics import silhouette_samples, silhouette_score\n\ncldf = df.drop(list(df.columns[df.isnull().any().values].values), axis=1)\n\ntext = []\n\nfor k in range(3,10):\n    # Debugging\n    print(\"Cluster count: \" + str(k))\n    \n    #############\n    # Do the clustering using the main columns\n    clusterer = KMeans(n_clusters=k, n_init=15, random_state=42, n_jobs=-1)\n    cluster_labels = clusterer.fit_predict(cldf)\n    \n    # Calculate the overall silhouette score\n    silhouette_avg = silhouette_score(cldf, cluster_labels)\n    text = text + [f\"For k={k} the average silhouette_score is: {silhouette_avg:6.4f}\"]\n    \n    # Calculate the silhouette values\n    sample_silhouette_values = silhouette_samples(cldf, cluster_labels)\n    \n    #############\n    # Create a subplot with 1 row and 2 columns\n    fig, (ax1, ax2) = plt.subplots(1, 2)\n    fig.set_size_inches(9, 5)\n\n    # The 1st subplot is the silhouette plot\n    # The silhouette coefficient can range from -1, 1\n    ax1.set_xlim([-1.0, 1.0]) # Changed from -0.1, 1\n    \n    # The (n_clusters+1)*10 is for inserting blank space between silhouette\n    # plots of individual clusters, to demarcate them clearly.\n    ax1.set_ylim([0, cldf.shape[0] + (k + 1) * 10])\n    \n    y_lower = 10\n    \n    # For each of the clusters...\n    for i in range(k):\n        # Aggregate the silhouette scores for samples belonging to\n        # cluster i, and sort them\n        ith_cluster_silhouette_values = \\\n            sample_silhouette_values[cluster_labels == i]\n\n        ith_cluster_silhouette_values.sort()\n\n        size_cluster_i = ith_cluster_silhouette_values.shape[0]\n        y_upper = y_lower + size_cluster_i\n        \n        # Set the color ramp\n        #cmap  = cm.get_cmap(\"Spectral\")\n        color = plt.cm.Spectral(i/k)\n        ax1.fill_betweenx(np.arange(y_lower, y_upper),\n                          0, ith_cluster_silhouette_values,\n                          facecolor=color, edgecolor=color, alpha=0.7)\n\n        # Label the silhouette plots with their cluster numbers at the middle\n        ax1.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))\n\n        # Compute the new y_lower for next plot\n        y_lower = y_upper + 10  # 10 for the 0 samples\n\n    ax1.set_title(\"The silhouette plot for the clusters.\")\n    ax1.set_xlabel(\"The silhouette coefficient values\")\n    ax1.set_ylabel(\"Cluster label\")\n\n    # The vertical line for average silhouette score of all the values\n    ax1.axvline(x=silhouette_avg, color=\"red\", linestyle=\"--\")\n\n    ax1.set_yticks([])  # Clear the yaxis labels / ticks\n    ax1.set_xticks(np.arange(-1.0, 1.1, 0.2)) # Was: [-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1]\n\n    # 2nd Plot showing the actual clusters formed --\n    # we can only do this for the first two dimensions\n    # so we may not see fully what is causing the \n    # resulting assignment\n    colors = plt.cm.Spectral(cluster_labels.astype(float) / k)\n    ax2.scatter(cldf[cldf.columns[0]], cldf[cldf.columns[1]], marker='.', s=30, lw=0, alpha=0.7,\n                c=colors)\n\n    # Labeling the clusters\n    centers = clusterer.cluster_centers_\n    \n    # Draw white circles at cluster centers\n    ax2.scatter(centers[:, 0], centers[:, 1],\n                marker='o', c=\"white\", alpha=1, s=200)\n\n    for i, c in enumerate(centers):\n        ax2.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50)\n\n    ax2.set_title(\"Visualization of the clustered data\")\n    ax2.set_xlabel(\"Feature space for the 1st feature\")\n    ax2.set_ylabel(\"Feature space for the 2nd feature\")\n\n    plt.suptitle((\"Silhouette analysis for KMeans clustering on sample data \"\n                  \"with n_clusters = %d\" % k),\n                 fontsize=14, fontweight='bold')\n\n    plt.show()\n\nprint(\"\\n\".join(text))    \n\ndel(cldf)\n```\n\n#### Interpreting the Results\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">STOP. Make sure that you understand how the silhouette plot and value work, and why your results may diverge from mine.\n\n:::\n\nWe can use the largest average silhouette score to determine the 'natural' number of clusters in the data, but that that's only if we don't have any kind of underlying _theory_, other _empirical evidence_, or even just a _reason_ for choosing a different value... Again, we're now getting in areas where _your judgement_ and your ability to _communicate your rationale_ to readers is the key thing. \n\n#### Final Clustering\n\nLet's repeat the clustering process _one more time_ using the silhouette score as a guide and then map it.\n\n```python\n#| scrolled: true\nc_nm = 'KMeans'\n# Quick sanity check in case something hasn't\n# run successfully -- these muck up k-means\ncldf = df.drop(list(df.columns[df.isnull().any().values].values), axis=1)\n\nk_pref = 4\nkmeans = KMeans(n_clusters=k_pref, n_init=75, random_state=42).fit(cldf)\n\n# Convert to a series\ns = pd.Series(kmeans.labels_, index=cldf.index, name=c_nm)\n\n# We do this for plotting\ncldf[c_nm] = s\n\n# We do this to keep track of the results\nresult_set=add_2_rs(s)\n```\n\n#### Mapping Results\n\n```python\ncgdf = gdf.join(cldf, how='inner')\n\nbreaks = np.arange(0,cldf[c_nm].max()+2,1)\ncmap   = default_cmap(len(breaks))\n\nnorm    = mpl.colors.BoundaryNorm(breaks, cmap.N)\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results (k={k_pref})\", fontsize=20, y=0.92)\ncgdf.plot(column=c_nm, ax=ax, cmap=cmap, norm=norm, linewidth=0, zorder=0)\n\nadd_colorbar(ax.collections[-1], ax, cmap, norm, breaks)\n\nplt.savefig(os.path.join(o_dir,f\"{c_nm}-{k_pref}.png\"), dpi=200)\ndel(cgdf)\n```\n\nTo make sense of whether this is a 'good' result, you might want to visit [datashine](http://datashine.org.uk/#table=QS607EW&col=QS607EW0050&ramp=RdYlGn&layers=BTTT&zoom=10&lon=-0.1751&lat=51.4863) or think back to last year when we examined the NS-SeC data. \n\nYou could also think of ways of plotting how these groups differ. For instance...\n\n#### 'Representative' Centroids\n\nTo get a sense of how these clusters differ we can try to extract 'representative' centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). In the case of _k_-means this will work quite will since the clusters are explicitly built around mean centroids. There's also a _k_-medoids clustering approach built around the median centroid.\n\n```python\ncentroids = None\nfor k in sorted(cldf[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n\n    clsoas = cldf[cldf[c_nm]==k]\n    if centroids is None:\n        centroids = pd.DataFrame(columns=clsoas.columns.values)\n    centroids = centroids.append(clsoas.mean(), ignore_index=True)\n\nodf = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    c_index = list(centroids.columns.values).index(c_nm)\n    for c in range(0,c_index):\n        d = {'Variable':centroids.columns[c], 'Cluster':row[c_index], 'Std. Value':row[c]}\n        odf = odf.append(d, ignore_index=True)\n\ng = sns.FacetGrid(odf, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.plot, \"Cluster\", \"Std. Value\", marker=\".\")\n\ndel(odf, centroids, cldf)\n```\n\n### DBScan\n\nOf course, as we've said above _k_-means is just one way of clustering, DBScan is another. Unlike _k_-means, we don't need to specify the number of clusters in advance. Which sounds great, but we still need to specify _other_ parameters (typically, these are known as _hyperparameters_ because they are about specifying parameters that help the aglorithm to find the right solution... or final set of parameters!) and these can have a huge impact on our results!\n\n#### Importing the Library\n\n```python\nfrom sklearn.cluster import DBSCAN\n#?DSCAN\n```\n\n#### Find a Reasonable Value for Epsilon\n\nBefore we an use DBSCAN it's useful to find a good value for Epsilon. We can [look for the point of maximum 'curvature'](https://towardsdatascience.com/machine-learning-clustering-dbscan-determine-the-optimal-value-for-epsilon-eps-python-example-3100091cfbc) in a nearest neigbhours plot. Which seems to be in the vicinity of 0.55. Tips on selecting `min_pts` can be [found here](https://towardsdatascience.com/how-dbscan-works-and-why-should-i-use-it-443b4a191c80).\n\n```python\n# Quick sanity check in case something hasn't\n# run successfully -- these muck up k-means\ncldf = df.drop(list(df.columns[df.isnull().any().values].values), axis=1)\n\nneigh = NearestNeighbors(n_neighbors=2)\nnbrs = neigh.fit(cldf)\ndistances, indices = nbrs.kneighbors(cldf)\n\ndistances = np.sort(distances, axis=0)\ndistances = distances[:,1]\nplt.plot(distances)\n```\n\n#### Exploration\n\nThere are two values that need to be specified: `eps` and `min_samples`. Both seem to be set largely by trial and error. It's easiest to set `min_samples` first since that sets a floor for your cluster size and then `eps` is basically a distance metric that governs how far away something can be from a cluster and still be considered part of that cluster.\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. This next step may take quite a lot of time since we are iterating through many, many values of Epsilon to explore how the clustering result changes and how well this matches up with (or doesn't) the graph above.\n\n:::\n\n```python\nc_nm = 'DBSCAN'\n\n# Quick sanity check in case something hasn't\n# run successfully -- these muck up k-means\ncldf = df.drop(list(df.columns[df.isnull().any().values].values), axis=1)\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.4f}'.format(x))\n\n# There's an argument for making min_samples = len(df.columns)+1\n\nel  = []\n\nmax_clusters  = 10\ncluster_count = 1\n\niters = 0\n\nfor e in np.arange(0.15, 1.55, 0.01):\n    \n    if iters % 25==0: print(f\"{iters} epsilons explored.\") \n    \n    # Run the clustering\n    dbs = DBSCAN(eps=e, min_samples=12, n_jobs=-1).fit(cldf.values)\n    \n    # See how we did\n    s = pd.Series(dbs.labels_, index=cldf.index, name=c_nm)\n    \n    row = [e]\n    data = s.value_counts()\n    for c in range(-1, max_clusters+1):\n        try:\n            row.append(data[c])\n        except KeyError:\n            row.append(None)\n    \n    el.append(row)\n    iters+=1\n\nedf = pd.DataFrame(el, columns=['Epsilon']+[\"Cluster \" + str(x) for x in list(range(-1,max_clusters+1))])\nedf.sample(random_state=42)\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))\n\nprint(\"Done.\")\n```\n\n```python\nodf = pd.DataFrame(columns=['Epsilon','Cluster','Count'])\n\nfor i in range(0,len(edf.index)):\n    row = edf.iloc[i,:]\n    for c in range(1,len(edf.columns.values)):\n        if not np.isnan(row[c]):\n            d = {'Epsilon':row[0], 'Cluster':f\"Cluster {c-2}\", 'Count':row[c]}\n            odf = odf.append(d, ignore_index=True)       \n```\n\n```python\nxmin = odf[odf.Cluster=='Cluster 0'].Epsilon.min()\nxmax = odf[(odf.Cluster=='Cluster -1') & (odf.Count < cldf.shape[0]/5)].Epsilon.min()\n\nfig, ax = plt.subplots(figsize=(12,8))\nax.set_xlim([xmin,xmax])\nsns.lineplot(data=odf, x='Epsilon', y='Count', hue='Cluster')\n```\n\n#### Final Clustering\n\n```python\ne = 0.835\ndbs = DBSCAN(eps=e, min_samples=12, n_jobs=-1).fit(cldf.values)\ns = pd.Series(dbs.labels_, index=cldf.index, name=c_nm)\ncldf[c_nm] = s\nresult_set=add_2_rs(s)\nprint(s.value_counts())\n```\n\n```python\ncgdf = gdf.join(cldf, how='inner')\n\nbreaks = np.arange(cldf[c_nm].min(),cldf[c_nm].max()+2,1)\ncmap   = default_cmap(len(breaks), outliers=True)\nnorm   = mpl.colors.BoundaryNorm(breaks, cmap.N, clip=False)\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results\", fontsize=20, y=0.92)\n\ncgdf.plot(column=c_nm, ax=ax, cmap=cmap, norm=norm, linewidth=0, zorder=0, legend=False)\n\nadd_colorbar(ax.collections[-1], ax, cmap, norm, breaks, outliers=True)\n\nplt.savefig(os.path.join(o_dir,f\"{c_nm}.png\"), dpi=200)\ndel(cgdf)\n```\n\n#### 'Representative' Centroids\n\nTo get a sense of how these clusters differ we can try to extract 'representative' centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). For algorithms other than _k_-means it may be better to use medians than means.\n\n```python\ncentroids = None\nfor k in sorted(cldf[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n\n    clsoas = cldf[cldf[c_nm]==k]\n    if centroids is None:\n        centroids = pd.DataFrame(columns=clsoas.columns.values)\n    centroids = centroids.append(clsoas.mean(), ignore_index=True)\n\nodf = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    c_index = list(centroids.columns.values).index(c_nm)\n    for c in range(0,c_index):\n        d = {'Variable':centroids.columns[c], 'Cluster':row[c_index], 'Std. Value':row[c]}\n        odf = odf.append(d, ignore_index=True)\n\n# Drop outliers\nodf = odf[odf.Cluster >= 0]\n\ng = sns.FacetGrid(odf, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.plot, \"Cluster\", \"Std. Value\", marker=\".\")\n\ndel(odf, centroids)\n```\n\n### OPTICS Clustering\n\nThis is a fairly new addition to `sklearn` and is similar to DBSCAN in that there are very few (if any) parameters to specify. This means that we're making fewer assumptions about the nature of any clustering in the data. It also allows us to have outliers that don't get assigned to _any_ cluster. The focus is mainly on local density, so in some sense it's more like a geographically aware clustering approach, but applied in the data space, not geographical space.\n\n#### Importing the Library\n\n```python\nfrom sklearn.cluster import OPTICS\n```\n\n#### Final Clustering\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. This next step may take quite a lot of time since the algorithm is making far fewer assumptions about the structure of the data. On a 2018 MacBook Pro with 16GB of RAM it took about 5 minutes.\n\n:::\n\n```python\nc_nm = 'Optics'\n\n# Can try to set this from DBSCAN results\ne = 0.9850\n\n# Quick sanity check in case something hasn't\n# run successfully -- these muck up k-means\ncldf = df.drop(list(df.columns[df.isnull().any().values].values), axis=1)\n\nimport math\n\n# Run the clustering\nopt = OPTICS(min_samples=len(df.columns)+1, max_eps=math.ceil(e * 100)/100, n_jobs=-1).fit(cldf.values)\n\n# See how we did\ns = pd.Series(opt.labels_, index=cldf.index, name=c_nm)\ncldf[c_nm] = s\nresult_set=add_2_rs(s)\n\n# Distribution\nprint(s.value_counts())\n```\n\n#### Mapping Clustering Results\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. My sense is that these results are a bit rubbish: the majority of items are assigned to *one cluster*??? I've tried PCA on the standardised data and that made little difference. This should also have worked *better* but it seems that a small number of LSOAs are so utterly different that the more sophisticated clustering algorithm effectively 'chokes' on them.\n\n:::\n\n```python\ncgdf = gdf.join(cldf, how='inner')\n\nbreaks = np.arange(cldf[c_nm].min(),cldf[c_nm].max()+2,1)\ncmap   = default_cmap(len(breaks), outliers=True)\nnorm   = mpl.colors.BoundaryNorm(breaks, cmap.N, clip=False)\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results\", fontsize=20, y=0.92)\n\ncgdf.plot(column=c_nm, ax=ax, cmap=cmap, norm=norm, linewidth=0, zorder=0, legend=False)\n\nadd_colorbar(ax.collections[-1], ax, cmap, norm, breaks, outliers=True)\n\nplt.savefig(os.path.join(o_dir,f\"{c_nm}.png\"), dpi=200)\ndel(cgdf)\n```\n\n#### 'Representative' Centroids\n\nTo get a sense of how these clusters differ we can try to extract 'representative' centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). For algorithms other than _k_-Means it may be better to use medians, not means.\n\n```python\ncentroids = None\nfor k in sorted(cldf[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n\n    clsoas = cldf[cldf[c_nm]==k]\n    if centroids is None:\n        centroids = pd.DataFrame(columns=clsoas.columns.values)\n    centroids = centroids.append(clsoas.mean(), ignore_index=True)\n\nodf = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    c_index = list(centroids.columns.values).index(c_nm)\n    for c in range(0,c_index):\n        d = {'Variable':centroids.columns[c], 'Cluster':row[c_index], 'Std. Value':row[c]}\n        odf = odf.append(d, ignore_index=True)\n\ng = sns.FacetGrid(odf, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.plot, \"Cluster\", \"Std. Value\", marker=\".\")\n\ndel(odf, centroids)\n```\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">STOP. Aside from the fact that we should probably reduce the number of dimensions on which we're clustering, what about the process of selecting variables (a.k.a. feature selection) might have led to the result that our results are a bit crap? *Hint: how did we decide what to keep and what to drop, and is this a robust approach?*\n\n:::\n\n### HDBSCAN\n\nNot implemented, but you could give it a try after installing the package:\n```bash\nconda activate <your environment name here>\nconda install -c conda-forge sklearn-contrib-hdbscan\n```\n\nThen it should be something like:\n```python\nimport hdbscan\nclusterer = hdbscan.HDBSCAN()\n# HDBSCAN(algorithm='best', alpha=1.0, approx_min_span_tree=True,\n#    gen_min_span_tree=False, leaf_size=40, memory=Memory(cachedir=None),\n#    metric='euclidean', min_cluster_size=5, min_samples=None, p=None)\nclusterer.fit(<data>)\nclusterer.labels_\n```\n\n### Hierarchical Clustering\n\nProbably not appropriate as it tends to be confused by noise.\n\n### Self-Organising Maps\n\nSOMs offer a third type of clustering algorithm. They are a relatively 'simple' type of neural network in which the 'map' (of the SOM) adjusts to the data: we're going to see how this works over the next few code blocks, but the main thing is that, unlike the above approaches, SOMs build a 2D map of a higher-dimensional space and use this as a mechanism for subsequently clustering the raw data. In this sense there is a conceptual link between SOMs and PCA or tSNE (another form of dimensionality reduction).\n\n#### (Re)Installing SOMPY\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. The maintainers of the main SOMPY library are fairly inactive, so we've had to write our own version that fixes a few Python3 bugs, but this means that it can't be installed the 'usual' way without also having Git installed. Consequently, I have left the output from SOMPY in place so that you can see what it will produce *even if you cannot successfully install SOMPY during this practical*\n\n:::. \n\nTo work out if there is an issue, check to see if the `import` statement below gives you errors:\n\n```python\nfrom sompy.sompy import SOMFactory\n```\n\nIf this import has failed with a warning about being unable to find SOM or something similar, then you will need to *re*-install SOMPY using a fork that I created on our Kings GSA GitHub account. For *that* to work, you will need to ensure that you have `git` installed. \n\nIf the following Terminal command (which should also work in the Windows Terminal) does not give you an error then `git` is already installed:\n```shell\ngit --version\n```\nTo install `git` on a Mac is fairly simple. Again, from the Terminal issue the following command:\n```shell\nxcode-select --install\n```\nThis installation may take some time over eduroam since there is a lot to download.\n\nOnce that's complete, you can move on to installing SOMPY from our fork. On a Mac this is done on the Terminal with:\n```shell\nconda activate <your kernel name here>\npip install -e git+git://github.com/kingsgeocomp/SOMPY.git#egg=SOMPY\nconda deactivate\n```\nOn Windows you probably drop the `conda` part of the command.\n\n#### Training the SOM\n\nWe are going to actually train the SOM using the input data. This is where you specify the input parameters that have the main effect on the clustering results.\n\n```python\nfrom sompy.sompy import SOMFactory\n```\n\n```python\nc_nm = 'SOM'\n\n# Quick sanity check in case something hasn't\n# run successfully -- these muck up k-means\ncldf = df.drop(list(df.columns[df.isnull().any().values].values), axis=1)\n\nsm = SOMFactory().build(\n    cldf.values, mapsize=(10,15),\n    normalization='var', initialization='random', component_names=cldf.columns.values)\nsm.train(n_job=4, verbose=False, train_rough_len=2, train_finetune_len=5)\n```\n\nHow good is the fit?\n\n```python\ntopographic_error  = sm.calculate_topographic_error()\nquantization_error = np.mean(sm._bmu[1])\nprint(\"Topographic error = {0:0.5f}; Quantization error = {1:0.5f}\".format(topographic_error, quantization_error))\n```\n\nHow do the results look?\n\n```python\nfrom sompy.visualization.mapview import View2D\nview2D = View2D(10, 10, \"rand data\", text_size=10)\nview2D.show(sm, col_sz=4, which_dim=\"all\", denormalize=True)\nplt.savefig(os.path.join(o_dir, f\"{c_nm}-Map.png\"), dpi=200)\n```\n\n#### Here's What I Got\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. These are the results from the approach that is closest to the one outlined in *Geocomputation*.\n\n:::\n\n<img src=\"https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM-Map.png\" alt=\"SOM Clustering Results\" width=\"800\" />\n\nHow many data points were assigned to each BMU?\n\n```python\nfrom sompy.visualization.bmuhits import BmuHitsView\nvhts = BmuHitsView(15, 15, \"Hits Map\", text_size=8)\nvhts.show(sm, anotate=True, onlyzeros=False, labelsize=9, cmap=\"plasma\", logaritmic=False)\nplt.savefig(os.path.join(o_dir,f\"{c_nm}-BMU Hit View.png\"), dpi=200)\n```\n\n#### BMU Hit Map\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. These are the results from the approach that is closest to the one outlined in *Geocomputation*.\n\n:::\n\n<img src=\"https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM-BMU Hit View.png\" alt=\"SOM Heat Map Results\" width=\"800\" />\n\nHow many clusters do we want and where are they on the map?\n\n```python\nfrom sompy.visualization.hitmap import HitMapView\n\nk_val = 5\nsm.cluster(k_val)\nhits  = HitMapView(15, 15, \"Clustering\", text_size=14)\na     = hits.show(sm)\nplt.savefig(os.path.join(o_dir,f\"{c_nm}-Hit Map View.png\"), dpi=200)\n```\n\n#### Clustering the BMUs\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. These are the results from the approach that is closest to the one outlined in *Geocomputation*.\n\n:::\n\n<img src=\"https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM-Hit Map View.png\" alt=\"SOM Clustering Results\" width=\"800\" />\n\nFinally, let's get the cluster results and map them back on to the data points:\n\n```python\n# Get the labels for each BMU\n# in the SOM (15 * 10 neurons)\nclabs = sm.cluster_labels\n\ntry:\n    cldf.drop(c_nm,inplace=True,axis=1)\nexcept KeyError:\n    pass\n\n# Project the data on to the SOM\n# so that we get the BMU for each\n# of the original data points\nbmus  = sm.project_data(cldf.values)\n\n# Turn the BMUs into cluster labels\n# and append to the data frame\ns = pd.Series(clabs[bmus], index=cldf.index, name=c_nm)\n\ncldf[c_nm] = s\nresult_set = add_2_rs(s)\n```\n\n```python\ncgdf = gdf.join(cldf, how='inner')\n\nbreaks = np.arange(cldf[c_nm].min(),cldf[c_nm].max()+2,1)\ncmap   = default_cmap(len(breaks))\nnorm   = mpl.colors.BoundaryNorm(breaks, cmap.N, clip=False)\n\nfig, ax = plt_ldn()\nfig.suptitle(f\"{c_nm} Results\", fontsize=20, y=0.92)\n\ncgdf.plot(column=c_nm, ax=ax, cmap=cmap, norm=norm, linewidth=0, zorder=0, legend=False)\n\nadd_colorbar(ax.collections[-1], ax, cmap, norm, breaks)\n\nplt.savefig(os.path.join(o_dir,f\"{c_nm}.png\"), dpi=200)\ndel(cgdf)\n```\n\n#### Result!\n\n<div style=\"padding:5px;margin-top:5px;margin-bottom:5px;border:dotted 1px red;background-color:rgb(255,233,233);color:red\">WARNING. These are the results from the approach that is closest to the one outlined in *Geocomputation*.\n\n:::\n\n<img src=\"https://github.com/kingsgeocomp/applied_gsa/raw/master/img/SOM.png\" alt=\"SOM Clustering Results Mapped\" width=\"800\" />\n\n#### Representative Centroids\n\n```python\ncentroids = None\nfor k in sorted(cldf[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n\n    clsoas = cldf[cldf[c_nm]==k]\n    if centroids is None:\n        centroids = pd.DataFrame(columns=clsoas.columns.values)\n    centroids = centroids.append(clsoas.mean(), ignore_index=True)\n\nodf = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    c_index = list(centroids.columns.values).index(c_nm)\n    for c in range(0,c_index):\n        d = {'Variable':centroids.columns[c], 'Cluster':row[c_index], 'Std. Value':row[c]}\n        odf = odf.append(d, ignore_index=True)\n\ng = sns.FacetGrid(odf, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.plot, \"Cluster\", \"Std. Value\", marker=\".\")\n\ndel(odf, centroids)\n```\n\n## Wrap-Up\n\n- Find the appropriate eps value: [Nearest Neighbour Distance Functions](https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Nearest-Neighbor-Distance-Functions) or [Interevent Distance Functions](https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Interevent-Distance-Functions)\n- [Clustering Points](https://darribas.org/gds_course/content/bH/lab_H.html#clusters-of-points)\n- [Regionalisation algorithms with Aglomerative Clustering](https://darribas.org/gds_course/content/bG/lab_G.html#regionalization-algorithms)\n\nYou've reached the end, you're done... \n\nEr, no. This is barely scratching the surface! I'd suggest that you go back through the above code and do three things:\n1. Add a lot more comments to the code to ensure that really have understood what is going on.\n2. Try playing with some of the parameters (e.g. my thresholds for skew, or non-normality) and seeing how your results change.\n3. Try outputting additional plots that will help you to understand the _quality_ of your clustering results (e.g. what _is_ the makeup of cluster 1? Or 6? What has it picked up? What names would I give these clsuters?).\n\nIf all of that seems like a lot of work then why not learn a bit more about machine learning before calling it a day?\n\nSee: [Introduction to Machine Learning with Scikit-Learn](http://www.slideshare.net/BenjaminBengfort/introduction-to-machine-learning-with-scikitlearn).\n\n",
    "supporting": [
      "Practical-X-Grouping_Data-Listings_Only_files"
    ],
    "filters": [],
    "includes": {}
  }
}
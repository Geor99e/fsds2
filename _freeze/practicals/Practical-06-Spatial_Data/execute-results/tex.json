{
  "hash": "4b6fbda31bdd8a3ece02d02114d1b387",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Practical 6: Spatial Data\"\nsubtitle: \"Getting to grips with Geo-Data using Geopandas\"\nexecute:\n  keep-ipynb: true\njupyter: python3\nfilters:\n  - qna\n  - quarto\n---\n\n\n| Complete | Part 1: Foundations | Part 2: Data | Part 3: Analysis |     |\n| :------- | :------------------ | :----------- | :--------------- | --: |\n| 50% | &#9619;&#9619;&#9619;&#9619;&#9619;&#9619;&#9619;&#9619; | &#9619;&#9619;&#9619;&#9617;&#9617;&#9617; | &#9617;&#9617;&#9617;&#9617;&#9617;&#9617; | 6/10\n\n<style type=\"text/css\">\n.longform {\n    max-height: 300px;\n    overflow-y: scroll;\n}\n</style>\n\nLast week we did some initial processing on the Inside Airbnb listings data, focussing on its *numeric* properties. This week we are going to focus on the *spatial* properties of the data set.\n\n::: {.callout-tip}\n\nIt makes life a lot easier if you gather all of the library import commands and configuration information (here having to do with `matplotlib`) in the first exectuable code block in a notebook or script. That way it's easy for you for others to see what what it is necessary to have installed before getting started!.\n\n:::\n\n# Preamble\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\n\nimport matplotlib\nimport matplotlib.font_manager\n# For debugging purposes (fonts can be hard)\nprint(matplotlib.get_cachedir())\n\n# We change fonts the hard way in this notebook...\n# but you can also do this to change the default \n# font everywhere in one go:\n# matplotlib.rcParams['font.family'] = \"Liberation Sans Narrow\"\nfontname = \"Liberation Sans Narrow\"\n\nmatplotlib.font_manager.FontManager().findfont(fontname, fontext='ttf', rebuild_if_missing=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n/Users/jreades/.matplotlib\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n'/Users/jreades/Library/Fonts/LiberationSansNarrow-Regular.ttf'\n```\n:::\n:::\n\n\n# Reading Geo-Data\n\n::: {.callout-note}\n\n#### &#128279; Connections\n\nWe're building on the work done in [Practical 5](Practical-05-Numeric_Data.ipynb) and [Practical 4](Practical-04-Objects.ipynb) (with a particular nod to the [lecture on Data](https://jreades.github.io/fsds/sessions/week5.html#lectures)) to create some useful functions that we can call on at-need to improve the ease of doing data analysis.\n\n:::\n\nI find GeoPackages and GeoParquet to be by far the easiest way to distribute geo-data now: they are a single file (in a database-like format that supports multiple types of data), include the projection information by default, and in some cases QGIS can even embed information about rendering style! \n\nWe're going to do something _similar_ to the `get_url` in order to download the file to our hard drive and save it there. The improvement is that we'll check to see if the file already exists and, if it does, return that so that you can don't have to keep downloading it week after week. \n\nYou'll need to add the documentation yourself and I've left a few `??` to challenge you.\n\n## Caching Remote Data\n\nWe don't want to continually download data over the Internet: 1) because it's not nice to whoever is hosting the data; and 2) because it requires you be online in order to run your code. So if we can 'cache' the data locally so that it's only downloaded once this makes life much, much easier.\n\nI've used the Numpy-style comments here, but the Google-style also look good in this context and all styles of answer are acceptable so long as they *work*. See overview of commenting styles [on DataCamp](https://www.datacamp.com/community/tutorials/docstrings-python).\n\n::: {.callout-tip}\n\nUse this as an opportunity to improve your ability to read code and to learn through documentation.\n\n:::\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty level: Moderate\n\n:::\n\n::: {.qna}\n\n#### Question\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport os\nfrom requests import get\nfrom urllib.parse import urlparse\n\ndef cache_data(src:str, dest:str) -> str:\n    \"\"\"\n    \n    ??\n    \n    \n    \"\"\"    \n    url = urlparse(src) # We assume that this is some kind of valid URL \n    fn  = os.path.split(url.path)[??] # Extract the filename\n    dfn = os.path.join(dest,fn) # Destination filename\n    \n    if not os.path.isfile(dfn) or os.path.getsize(dfn) < 250:\n        \n        print(f\"{dfn} not found, downloading!\")\n\n        path = os.path.split(dest)\n        \n        if len(path) >= 1 and path[0] != '':\n            os.makedirs(os.path.join(*path), exist_ok=True)\n            \n        with open(dfn, \"wb\") as file:\n            response = get(src)\n            file.write(??.content)\n            \n        print(\"\\tDone downloading...\")\n\n    else:\n        print(f\"Found {dfn} locally!\")\n\n    return dfn\n\nhelp(cache_data) # <- This should show the docstring you've written\n```\n:::\n\n\n#### Answer\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport os\nfrom requests import get\nfrom urllib.parse import urlparse\n\ndef cache_data(src:str, dest:str) -> str:\n    \"\"\"Downloads and caches a remote file locally.\n\n    The function sits between the 'read' step of a pandas or geopandas\n    data frame and downloading the file from a remote location. The idea\n    is that it will save it locally so that you don't need to remember to\n    do so yourself. Subsequent re-reads of the file will return instantly\n    rather than downloading the entire file for a second or n-th itme.\n\n    We've built in some basic logic around looking at the extension of the\n    destination file and converting it accordingly *once* it is downloaded.\n\n    Parameters\n    ----------\n    src : str\n        The remote *source* for the file, any valid URL should work.\n    dest : str\n        The *destination* location to save the downloaded file.\n\n    Returns\n    -------\n    str\n        A string representing the local location of the file.\n    \"\"\"\n\n    url = urlparse(src) # We assume that this is some kind of valid URL\n    fn  = os.path.split(url.path)[-1] # Extract the filename\n    dfn = os.path.join(dest,fn) # Destination filename\n\n    if not os.path.isfile(dfn) or os.path.getsize(dfn) < 250:\n\n        print(f\"{dfn} not found, downloading!\")\n\n        path = os.path.split(dest)\n\n        if len(path) >= 1 and path[0] != '':\n            os.makedirs(os.path.join(*path), exist_ok=True)\n\n        with open(dfn, \"wb\") as file:\n            response = get(src)\n            file.write(response.content)\n\n        print(\"\\tDone downloading...\")\n\n    else:\n        print(f\"Found {dfn} locally!\")\n\n    return dfn\n\nhelp(cache_data) # <- This should show the docstring you've written\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on function cache_data in module __main__:\n\ncache_data(src: str, dest: str) -> str\n    Downloads and caches a remote file locally.\n\n    The function sits between the 'read' step of a pandas or geopandas\n    data frame and downloading the file from a remote location. The idea\n    is that it will save it locally so that you don't need to remember to\n    do so yourself. Subsequent re-reads of the file will return instantly\n    rather than downloading the entire file for a second or n-th itme.\n\n    We've built in some basic logic around looking at the extension of the\n    destination file and converting it accordingly *once* it is downloaded.\n\n    Parameters\n    ----------\n    src : str\n        The remote *source* for the file, any valid URL should work.\n    dest : str\n        The *destination* location to save the downloaded file.\n\n    Returns\n    -------\n    str\n        A string representing the local location of the file.\n\n```\n:::\n:::\n\n\n:::\n\n## Downloading the Data\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty level: Low, if your function works!\n\n:::\n\n### Geopackages\n\nUse the function above to download and cache the GeoPackage files found [on GitHub](https://github.com/jreades/fsds/tree/master/data/src) for Boroughs, Water, and Greenspace, then pass the output of these to GeoPandas. If you have been having trouble downloading files from GitHub, then use the understanding of the function developed above to download the file manually and place it where this function expects to find it!\n\n::: {.qna}\n\n#### Question\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nddir  = os.path.join('data','geo') # destination directory\nspath = 'https://github.com/jreades/i2p/blob/master/data/src/' # source path\n\nboros = gpd.read_file( ??(spath+'Boroughs.gpkg?raw=true', ddir) )\nwater = gpd.read_file( ??(spath+'Water.gpkg?raw=true', ddir) )\ngreen = gpd.read_file( ??(spath+'Greenspace.gpkg?raw=true', ddir) )\n\nprint('Done.')\n```\n:::\n\n\n#### Answer\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nddir  = os.path.join('data','geo') # destination directory\nspath = 'https://github.com/jreades/fsds/blob/master/data/src/' # source path\n\nboros = gpd.read_file( cache_data(spath+'Boroughs.gpkg?raw=true', ddir) )\nwater = gpd.read_file( cache_data(spath+'Water.gpkg?raw=true', ddir) )\ngreen = gpd.read_file( cache_data(spath+'Greenspace.gpkg?raw=true', ddir) )\n\nprint('Done.')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound data/geo/Boroughs.gpkg locally!\nFound data/geo/Water.gpkg locally!\nFound data/geo/Greenspace.gpkg locally!\nDone.\n```\n:::\n:::\n\n\n:::\n\n### Parquet\n\nLet's re-use our `cache_data` function to download and save the full Inside Airbnb data set. Again, if you have trouble with downloading via code, use your understanding of the function to work out where to save your own copy of this file so that the function works as expected.\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty level: Low\n\n:::\n\n::: {.qna}\n\n#### Question\n\n```python\n# Set download URL\nymd  = '2023-09-06'\nhost = 'https://orca.casa.ucl.ac.uk'\nurl  = f'{host}/~jreades/data/{ymd}-listings.parquet'\n\n# your code here\ndf = pd.read_parquet( ??(??, os.path.join('data','raw')) )\nprint(f\"Data frame is {df.shape[0]:,} x {df.shape[1]}\")\n```\n\n#### Answer\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Set download URL\nymd  = '2023-09-06'\nhost = 'https://orca.casa.ucl.ac.uk'\nurl  = f'{host}/~jreades/data/{ymd}-listings.parquet'\n\n# your code here\ndf = pd.read_parquet( cache_data(url, os.path.join('data','raw')) )\nprint(f\"Data frame is {df.shape[0]:,} x {df.shape[1]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFound data/raw/2023-09-06-listings.parquet locally!\nData frame is 85,134 x 30\n```\n:::\n:::\n\n\n:::\n\nYou should see that the file was 'not found' so 'downloading' happened and then the size of the data frame was printed out.\n\n# 'Writing' Geo-Data\n\nOf course, you will also often encounter geo-data that is not yet 'geographically enabled'; the two most frequent contexts for this are:\n\n1. The data represents points and is provided with latitude and longitude (or similar) as separate columns in a non-geographic data set.\n2. The data represents polygons but is provided _separately_ from the polygons themselves and so cannot be shown on a map without being 'joined' to the geography first.\n\nWe'll tackle each of these eventually, but for now we're going to focus on the first option.\n\n## Creating a GeoDataFrame\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty Level: Low\n\n:::\n\nRight, we're finally there! We need to convert our coordinates into some kind of geo-data. GeoPandas offers two ways to do this: the original way using `zip` and a new utility method called `points_from_xy`. Here's the old way:\n\n```python\nfrom shapely.geometry import Point\ngdf = gpd.GeoDataFrame(df, \n                geometry=[Point(x,y) for x, y in zip(df.Longitude,df.Latitude)])\n```\n\nNote, however, that this did not automatically set a projection, unlike the new approach with the 'helper function':\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ngdf = gpd.GeoDataFrame(df,\n      geometry=gpd.points_from_xy(df.longitude, df.latitude, crs='epsg:4326'))\n```\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(type(gdf))\nprint(type(gdf.geometry))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'geopandas.geodataframe.GeoDataFrame'>\n<class 'geopandas.geoseries.GeoSeries'>\n```\n:::\n:::\n\n\n## Saving Geo-Data Locally\n\n### Think Storage Formats\n\nWe want to save the InsideAirbnb GeoDataFrame to the 'geo' directory, but first let's see [what file formats are supported](https://geopandas.org/en/stable/docs/user_guide/io.html).\n\n| Format    | Advantages      | Disadvantages   |\n| :-------- | :-------------- | :-------------- |\n| Shapefile | Wide support    | Easy to break via loss of individual file element and not very efficient format |\n| GeoJSON   | Human-readable  | Highly inefficient storage format | \n| GeoPackage | Lightweight spatial database with benefits of indexing | Lightweight spatial database with limits on data types supported | \n| Parquet   | Highly compressed columnar database | Limited GIS support (except QGIS) |\n\n**GeoPackages** are really well-supported by QGIS: you can even embed multiple layers with different style information so that your final analysis is easy to distribute; however, they also carry quite a bit of overhead that makes them inefficient for distributing smaller data sets, while *also* not supporting the full spectrum of Pythonic data structures such as categorical data or lists.\n\n**GeoParquet** is an extension of the Parquet format. For working with large data sets this has revolutionised my workflow: getting excited about a columnar database might seem a bit... nerdy... but it's been transformative for many data scientists. First, because the data set is columnar you only read in the data that you need, so reading Parquet file is blindingly fast. Second, you can stream data from a Parquet file over the Internet, so that means you even gain these advantages reading remote files. Third, you have full support for Python data types, including (up to a point) objects. And, fourth, you can treat multiple Parquet files with the same layout as a single data set or mutiple Parquet files with different layouts as tables in a single database!\n\n\n### Specifying a Driver\n\nSince there are _many_ formats in which to save geo-data, rather than have multiple `to_format_x` methods, GeoPandas has _one_ for local files (`to_file`). If you are reading/writing a filename than ends in a valid extension (e.g. `.shp`, `.gpkg`, or `.geojson`) then GeoPandas will 'do the right thing'. Where you *may* run into trouble is if you are reading/writing a **URL** (e.g. [https://github.com/jreades/fsds/blob/master/data/src/Boroughs.gpkg?raw=true](https://github.com/jreades/fsds/blob/master/data/src/Boroughs.gpkg?raw=true)). With a URL ending in `?raw=true` there's no extension that GeoPandas can see so you *will* need to specify a driver. If in doubt, specify the driver.\n\n::: {.callout-note}\n\n#### Clarification\n\nIn this practical we are reading geodata from GitHub and I'm saying that we need to specify the driver. So why didn't we need to do with the `cache_data` function earlier as well? Well, this was a side-benefit of using the standard URL library: it *automatically* stripped off the query string (`?raw=true`) when I asked it for the file name, so we saved the file locally as a GeoPackage with `.gpkg` extension, which means that GeoPandas could read it without any problems.\n\n:::\n\nSo the following two bits of code are equivalent:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# This *may* not always do what we want, but should be fine for local files\nboros.to_file('test.gpkg') \n```\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# This is safer if working across computers/the Internet\nboros.to_file('test.gpkg', driver='GPKG')\n```\n:::\n\n\nSo, starting with <code>fn = '2023-09-06-listings.gpkg'</code>\n\n\n\n\nNotice the difference:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code .code-overflow-scroll}\nprint(f\"Using '{fn}' as basis for saving data...\")\ntry:\n   gdf.to_file(os.path.join('data','geo',fn), driver='GPKG')\nexcept TypeError as e:\n    print(\"Caught type error...\")\n    print(str(e)[:1000] + \" ...\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUsing '2023-09-06-listings.gpkg' as basis for saving data...\nCaught type error...\nCannot interpret 'CategoricalDtype(categories=['Barn', 'Boat', 'Camper/RV', 'Campsite', 'Casa particular',\n                  'Castle', 'Dome', 'Earthen home', 'Entire bungalow',\n                  'Entire cabin', 'Entire chalet', 'Entire condo',\n                  'Entire cottage', 'Entire guest suite', 'Entire guesthouse',\n                  'Entire home', 'Entire home/apt', 'Entire loft',\n                  'Entire place', 'Entire rental unit',\n                  'Entire serviced apartment', 'Entire townhouse',\n                  'Entire vacation home', 'Entire villa', 'Farm stay', 'Floor',\n                  'Houseboat', 'Hut', 'Island', 'Minsu', 'Private room',\n                  'Private room in bed and breakfast', 'Private room in boat',\n                  'Private room in bungalow', 'Private room in cabin',\n                  'Private room in camper/rv',\n                  'Private room in casa particular', 'Private room in chalet',\n                  'Private room in condo', 'Private room  ...\n```\n:::\n:::\n\n\nIf you try to save as a GeoPackage file then the code above typically throws a `TypeError` because of the presence of Categorical data.\n\nBut the below, in which we specify as a 'geoparquet' because of the coordinate data, does not:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfn = fn.replace('.gpkg','.geoparquet')\ngdf.to_parquet(os.path.join('data','geo',fn))\nprint(\"Saved.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSaved.\n```\n:::\n:::\n\n\n## Spatial Indexing\n\nIt's also worth comparing the output of a point with the output of a polygon or multi-polygon because you may well come across data in formats (e.g. WKT) resembling both of these in real data sets and they *can* be read as well. Notice too that we can use `loc` and `iloc` accessor methods to pull individual points and polygons out of a GeoDataFrame!\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint(gdf.geometry.iloc[1]) # Print out the object's contents\ngdf.geometry.iloc[1] # The object knows how to print itself as a point\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPOINT (-0.21707 51.49993)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-16-output-2.svg){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Object to string then print out first 399 characters\nprint(str(boros.geometry.iloc[1])[:399] + \"...\") \n# So this is a multi-polygon boundary\nboros.geometry.iloc[1] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMULTIPOLYGON (((535009.2 159504.7, 535005.5 159502, 535002.9 159500.1, 535000.1 159503.2, 535000 159503.2, 534747.8 159517.8, 534588 159522.1, 534512.3 159780.5, 534474.8 159760.8, 534398.8 159726.7, 534391.9 159723.3, 534378.9 159712.4, 534345.1 159702.8, 534314.3 159691.8, 534292.7 159683.9, 534253.1 159666.6, 534229.4 159657.9, 534207.5 159654.6, 534160.5 159651.5, 534159.7 159637.1, 534109.5 ...\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-17-output-2.svg){fig-pos='H'}\n:::\n:::\n\n\nSo each element of this Series has text indicating the type of shape the geometry applies to (e.g. _POLYGON_) followed by a bunch of numbers. These numbers are truncated here just to make things a little more legible.\n\n# Checking the Data\n\n### Checking Numeric Data\n\nBefore we mindlessly convert the parquet data to mappable geo-data it might make sense to sanity-check it. GeoPandas has a `total_bounds` method that gives us the bounding box for a GeoSeries, but how would we do that in Pandas?\n\n::: {.callout-tip}\n\nThink about what the 'total bounds' (or 'envelope') of a point data set is. You have already seen the pandas functions you'll need to _find_ these...\n\n:::\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty level: Moderate\n\n:::\n\n:::: {.qna}\n\n#### Question\n\n```python\nprint(f\"The bottom-left corner is {??}, {??}\")\nprint(f\"The top-right corner is {??}, {??}\")\n```\n\nYour answer should produce the following:\n\n\n\nThe bottom-left corner is \\-0\\.5, 51\\.3\n\nThe top-right corner is 0\\.3, 51\\.7\n\n#### Answer\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nprint(f\"The bottom-left corner is {df.longitude.min():0.1f}, {df.latitude.min():0.1f}\")\nprint(f\"The top-right corner is {df.longitude.max():0.1f}, {df.latitude.max():0.1f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe bottom-left corner is -0.5, 51.3\nThe top-right corner is 0.3, 51.7\n```\n:::\n:::\n\n\n::::\n\n### Checking via a Plot\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty level: Low\n\n:::\n\nWe'll see how you control figure-making more effectively later, but for now let's just see what they look like using GeoPanda's plotting functionality. If you don't see what you expected then the problem could be quite basic/fundamental.\n\n:::: {.qna}\n\n#### Question\n\n```python\nfor ??:\n    ??.plot()\n```\n#### Answer\n\nNote that here the data has *already* been reprojected so we're looking as `EPSG:27700` and not `EPSG:4326`.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfor g in [boros,water,green]:\n    g.plot()\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-20-output-1.pdf){fig-pos='H'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-20-output-2.pdf){fig-pos='H'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-20-output-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\n### Checking the Projection\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty level: Low\n\n:::\n\nCheck the projection of each GeoDataFrame using a for loop and the `crs` attribute.\n\n:::: {.qna}\n\n#### Question\n\n```python\nfor g in [??]:\n    print(g.??)\n```\n\n#### Answer\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nfor g in [boros,water,green]:\n    print(g.crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEPSG:27700\nEPSG:27700\nEPSG:27700\n```\n:::\n:::\n\n\n::::\n\nYou should see that all three are in the [EPSG:27700 CRS](https://epsg.io/27700) which is a common one for analysis using GB data.\n\n### Reprojecting the Data\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty Level: Low\n\n:::\n\nLet's start by taking our InsideAirbnb data in its original projection...\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nprint(gdf.geometry.crs)\nprint(gdf.total_bounds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nepsg:4326\n[-0.4978     51.295937    0.29573069 51.6816423 ]\n```\n:::\n:::\n\n\n... and reprojecting this into the `OSGB1936/BNG` CRS:\n\n:::: {.qna}\n\n#### Question\n\n```python\ngdf = gdf.??(??) # There is no 'in_place=True' option here.\nprint(gdf.geometry.crs)\nprint(gdf.total_bounds)\n```\n\n#### Answer\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\ngdf = gdf.to_crs('epsg:27700') # There is no 'in_place=True' option here.\nprint(gdf.geometry.crs)\nprint(gdf.total_bounds)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nepsg:27700\n[504110.58907151 156900.42075072 559262.78761517 199928.53721747]\n```\n:::\n:::\n\n\n::::\n\nNotice the change in total bounds from lat/long to Northing/Easting.\n\n# Simple Mapping\n\nThe files we've just downloaded all contain polygons, and the adjustments for points are different, but it's worth seeing how you can tweak these before we start combining them. Behind the scenes, GeoPandas is using `matplotlib` to render the map, so let's play with the colours to get the _start_ of something map-like. \n\nYou will want to look both at [how to make maps in GeoPandas](https://geopandas.org/mapping.html) and  at the different ways to [specify colours in Matplotlib](https://matplotlib.org/3.1.1/tutorials/colors/colors.html#specifying-colors). For the greenspace map you are looking for information about tuples... which can have three or four elements.\n\n## Work Out the Colour Scheme\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty level: Moderate\n\n:::\n\n::: {.callout-caution}\n\nR and Python take *very* different approaches to plotting. Do *not* think of Python's output as being 'maps' in the GIS sense, they are composed of 'patches' of color on abstract 'axes' that can use any arbitrary coordinate space. So colours are 'really' triplet (or quadruplet if you have alpha-blending transparency) values in the range 0.0-1.0. Annotations are then added in similarly abstract fashion.\n\n:::\n\nI'd **suggest** the following colour scheme as a way to test out different ways of specifying colour (though anything you like is fine so long as you manipulate the colours):\n\n- The boroughs can have red edges and white fill with a thick edge.\n- The water should have no edges and XKCD Lightblue fill.\n- The greenspace should have edges and faces specified using different 'alpha blending' (i.e. transparency) levels.\n\n### Boroughs\n\nBy way of a hint, matplotlib uses `edgecolor` and `facecolor` for controlling 'patches' (which is what polygons are considered), but the thicker-than-default line-width is specified differently (you'll need to look this up). So the intention is:\n\n1. Thick red borough borders, and \n2. White fill colour.\n\nJust to drive home how different this is from R, you can find the answer to question 1 [on the page for bar plots](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.bar.html).\n\n:::: {.qna}\n\n#### Question\n\n```python\nboros.plot(??)\n```\n\n#### Answer\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nboros.plot(edgecolor='red', facecolor='white', linewidth=1.5, figsize=(8,6))\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-24-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYour plot should look similar to this:\n\n::: {.cell execution_count=24}\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-25-output-1.pdf){}\n:::\n:::\n\n\n### Water\n\nThe process is the same as above, but I'd like you to work out how to specify:\n1. _No_ color for an edge, and \n2. An XKCD color for the face.\n\n:::: {.qna}\n\n#### Question\n\n```python\nwater.plot(??)\n```\n#### Answer\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nwater.plot(edgecolor=\"none\", facecolor='xkcd:lightblue', figsize=(8,6))\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-26-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYour plot should look similar to this:\n\n::: {.cell execution_count=26}\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-27-output-1.pdf){}\n:::\n:::\n\n\n### Greenspace\n\nThe process is _also_ the same as above, but I'd like you to work out how to specify colours and transparency using RGBA (red-green-blue-alpha transparency) tuples. So we're looking for:\n1. No edge color.\n2. A partially transparent green specified as a 'tuple' (4 numbers in parentheses in the range 0.0-1.0).\n\n:::: {.qna}\n\n#### Question\n\n```python\ngreen.plot(??)\n```\n\n#### Answer\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ngreen.plot(edgecolor='none', facecolor=(0.7, 0.7, 0.14, 0.25), figsize=(8,6))\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-28-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYour plot should look similar to this:\n\n::: {.cell execution_count=28}\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-29-output-1.pdf){}\n:::\n:::\n\n\n## Combining Layers\n\n::: {.callout-warning}\n\nR and Python take *very* different approaches to plotting. Do *not* think of Python's output as being 'maps' in the GIS sense, they are composed of 'patches' of color on abstract 'axes' that can use any arbitrary coordinate space. So colours are 'really' numerical triplets (or quadruplets if you have transparency as well) in the range 0.0-1.0. Annotations are then added in similarly abstract fashion.\n\n:::\n\nNow that we've got our layers looking roughly how we want them, it's time to combine them. This is also reliant on `matplotlib` and basically involves plotting items to _shared axes_ which is done by passing in `ax=<axis object>` to each `plot(...)`. By convention, if you only have a single figure (e.g. a single map) then you create an axis object and name it `ax` so you will see a lot of `ax=ax` code in graphing libraries, but `=ax` is just saying 'assign to the axis object that I created'.\n\nSince the axes are how you control what is shown, see if you can find out by Googling how to set the x- and y-limits on the map so that it shows only London and trims out the much larger area of water that is outside of the Greater London Authority. **As a rough guideline, this has the Easting range 501,000 to 563,000, and the Northing range 155,000 to 202,000.**\n\nYou can set these limits before or after you start adding layers to the 'map', but it's probably easier conceptually to add them after with the idea of 'zooming in' on the features of interest. It's also easier to debug since you can start by seeing if you can plot the elements at all, and _then_ add the limits to zoom.\n\n**So the steps are:**\n\n1. Write the code to plot every image on the same set of axes (I've given you something to get started).\n2. Google how to set the limits of the map and then use the ranges I've offered above.\n3. Work out how to change the width of the edges for the boroughs layer. \n4. Save it somewhere local so that you could, say, load it into a Markdown file!\n\n::: {.callout-tip}\n\nThis is a first pass at a map, over the next few weeks we'll see how to add things like axis labels and titles to make it more 'map-like'. We don't have quite the built-in functionality of `ggplot` alas, but Python is advancing very quickly in this area. There is even [an implementation of ggplot in Python](https://github.com/yhat/ggpy), but it's functionality is more limited. In fact, there's [more than one](https://github.com/has2k1/plotnine)...\n\n:::\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty level: Hard\n\n:::\n\n:::: {.qna}\n\n#### Question\n\n```python\n# Creates a new figure with specified number of\n# subplots (we'll see more of this later) and \n# and the specified size (in inches by default).\nfig, ax = plt.subplots(1,1, figsize=(9,6))\n\n# Plot all three GeoPackages to the same axes\nwater.plot(??, ax=ax)\ngreen.??\nboros.??\n\n# Set the x and y limits\n\n\n# Save the image (dpi is 'dots per inch')\nos.??('img', exist_ok=True)\nplt.savefig(os.path.join('img','My_First_Map.png'), dpi=150)\n```\n\n#### Answer\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Creates a new figure with specified number of\n# subplots (we'll see more of this later) and\n# and the specified size (in inches by default).\nf,ax = plt.subplots(1,1, figsize=(9,6))\n\n# Plot all three GeoPackages to the same axes\nwater.plot(edgecolor=\"none\", facecolor='xkcd:lightblue', ax=ax)\ngreen.plot(edgecolor=(0.7, 0.7, 0.14, 0.25), facecolor=(0.7, 0.7, 0.14), ax=ax)\nboros.plot(edgecolor=(0.8, 0, 0, 0.5), facecolor='none', linewidth=2.5, ax=ax)\n\n# Set the x and y limits\nax.set_xlim(501000,563000)\nax.set_ylim(155000,202000)\n\n# Save the image (dpi is 'dots per inch')\nos.makedirs('img', exist_ok=True)\n\n# This is how you'd save an image output\n#plt.savefig(os.path.join('img','My_First_Map.png'), dpi=150)\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-30-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYou may wish for a different look, but here's one version of the output:\n\n::: {.cell execution_count=30}\n\n::: {.cell-output .cell-output-display execution_count=26}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-31-output-1.pdf){}\n:::\n:::\n\n\n## Choropleth Plots\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty Level: Low\n\n:::\n\nNow that we've converted the InsideAirbnb data to a GeoDataFrame, we can plot it, reproject it, etc.\n\nSee if you can work out how to plot the points coloured by their price using the appropriate BNG projection.\n\n:::: {.qna}\n\n#### Question\n\n```python\ngdf.to_crs(??).plot(column=??, cmap=??, alpha=0.25, markersize=1, figsize=(10,7));\n```\n\n#### Answer\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ngdf.to_crs('epsg:27700').plot(column='price', cmap='viridis', alpha=0.25, markersize=1, figsize=(10,7));\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-32-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nUsing the Viridis colourmap I get the following:\n\n::: {.cell execution_count=32}\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-33-output-1.pdf){}\n:::\n:::\n\n\n### Work out the Data Range\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty level: Low\n\n:::\n\nAs we saw above with the point-plot, in its original form the pricing data will not reveal much of interest because of the range of the data. However, as you will have seen in QM already (and as we explore in greater detail in Weeks 7/8), using *transformations* we can manipulate the data to increase its tractability for analysis.\n\nLet's start by getting a feel for the full data set in terms of the range of prices that it contains:\n\n:::: {.qna}\n\n#### Question\n\n```python\nprint(f\"The range of price is ${??:,.2f} to ${??:,.2f}\")\nprint(f\"The mean and median of the price are ${??:,.2f} and ${??:,.2f}\")\n```\n\n#### Answer\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nprint(f\"The range of price is ${gdf.price.min():,.2f} to ${gdf.price.max():,.2f}\")\nprint(f\"The mean and median of the price are ${gdf.price.mean():,.2f} and ${gdf.price.median():,.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe range of price is $0.00 to $80,100.00\nThe mean and median of the price are $183.62 and $112.00\n```\n:::\n:::\n\n\n::::\n\nNotice the neat little comma-separated thousands in there? That's fairly easy to do in English, but to use a thousands separator common to another language you would need to do something [a little more tricky](https://stackoverflow.com/questions/13082620/how-can-i-print-a-float-with-thousands-separators). \n\n### Inheritance!\n\nWe already know that GeoPandas _inherits_ functionality from Pandas, but let's formalise this... \n\nFirst, let's check what class of object `gdf` is using the [`isinstance`](https://www.w3schools.com/python/ref_func_isinstance.asp) function:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n# Is gdf a GeoDataFrame object?\nif isinstance(gdf, gpd.GeoDataFrame): \n    print(\"\\tI'm a geopandas data frame!\")\n\n# Is gdf *also* a DataFrame object?\nif isinstance(gdf, pd.DataFrame): \n    print(\"\\tI'm a pandas data frame!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\tI'm a geopandas data frame!\n\tI'm a pandas data frame!\n```\n:::\n:::\n\n\n### Benefiting from Inheritance\n\n*That* result means that we can also investigate the data using, for instance, a pandas histogram:\n\n:::: {.qna}\n\n#### Question\n\n```python\n# Oooooh, let's use a *pandas* method here\ngdf.price.plot.??(bins=??, figsize=(10,3)); \n```\n\n#### Answer\n\nNotice the difference between these two outputs, make sure that you understand why these differ so enormously:\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n# Oooooh, let's use a *pandas* method here\ngdf.price.plot.hist(bins=200, xlim=(0,1000), figsize=(9,3)); \n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-36-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n# Oooooh, let's use a *pandas* method here\ngdf[gdf.price < 1000].price.plot.hist(bins=200, figsize=(9,3)); \n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-37-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nNotice how we've used our GeoDataFrame *as if* it's a plain old DataFrame here? That's the miracle of Object-Oriented Design: we can do *anything* we would with a regular Pandas `df` as we do with a GeoPandas `gdf` because GeoPandas *inherits* all the methods of its parent super-class.\n\nWe can see that there's very little data above (at a guess) about $2,000, but at this scale it's hard to tell. We've already seen that you can use axes limits to adjust the display of a map, but the same technique applies to plain old plots because they're fundamentally the *same thing*.\n\nTry adjusting the axis so that the x-range is 0..2500:\n\n```python\nax = gdf.price.plot.??(bins=??, figsize=(9,3));\nax.??\n```\n\nYou can do the same thing with a boxplot:\n\n:::: {.qna}\n\n#### Question\n\n```python\nax = gdf.price.plot.??(vert=False, figsize=(10,3))\nax.??\n```\n#### Answer\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nax = gdf.price.plot.box(vert=False, figsize=(10,3))\nax.set_xlim(0,2500)\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-38-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\n[More complex](https://stackoverflow.com/a/54023612/4041902) formatting is also possible if you really know your pandas and your matplotlib:\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ngdf.price.plot(kind='box', vert=False, \n             color=dict(boxes='r', whiskers='r', medians='r', caps='r'),\n             boxprops=dict(linestyle='-', linewidth=1.5),\n             flierprops=dict(linestyle='-', linewidth=1.5),\n             medianprops=dict(linestyle='-', linewidth=1.5),\n             whiskerprops=dict(linestyle='-', linewidth=1.5),\n             capprops=dict(linestyle='-', linewidth=1.5),\n             showfliers=False, grid=False, rot=0);\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-39-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Truncate and Transform\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty level: Hard\n\n:::\n\n### Working it Out\n\nAnyway, drawing on everything we've seen over the past couple of weeks (and in *this* practical) I'd like you to:\n\n1. Try to take the natural-log of the price (*hint*: use `numpy`) and assign to a new Series called `lnprice`.\n2. Work out what the error means.\n3. Work out how to fix the error and *then* repeate step 1.\n4. Work out how many rows were affected.\n5. Report on the new min/max values.\n6. Work out if other outliers need to be removed (use code from above).\n7. Remove outliers and then continue with your work...\n\n```python\n# Use this as a 'scratch space' to work out what's needed below...\n```\n\n:::: {.qna}\n\n#### Question\n\n```python\nprint(f\"gdf has {gdf.shape[0]:,.0f} rows.\")\n\n# ---------- Do the processing -------------\n# You may need more than one of these 'drops'\n# to get the data the way you want...\ngdf.drop(gdf[??].index, axis=0, inplace=True)\ngdf['lnprice'] = np.log(gdf.price)\n\n# ---------- Check effects -----------\nprint(f\"gdf now has {gdf.shape[0]:,.0f} rows.\")\nprint(f\"The range of price is {gdf.price.min():,.2f} to {gdf.price.max():,.2f}\")\nprint(f\"The range of ln(price) is {gdf.lnprice.min():,.4f} to {gdf.lnprice.max():,.4f}\")\n\ngdf.price.plot(kind='box', vert=False, \n             color=dict(boxes='r', whiskers='r', medians='r', caps='r'),\n             boxprops=dict(linestyle='-', linewidth=1.5),\n             flierprops=dict(linestyle='-', linewidth=1.5),\n             medianprops=dict(linestyle='-', linewidth=1.5),\n             whiskerprops=dict(linestyle='-', linewidth=1.5),\n             capprops=dict(linestyle='-', linewidth=1.5),\n             showfliers=False, grid=False, rot=0);\nplt.title(\"Price (Outliers not shown)\")\nplt.show()\n\ngdf.lnprice.plot(kind='box', vert=False, \n             color=dict(boxes='r', whiskers='r', medians='r', caps='r'),\n             boxprops=dict(linestyle='-', linewidth=1.5),\n             flierprops=dict(linestyle='-', linewidth=1.5),\n             medianprops=dict(linestyle='-', linewidth=1.5),\n             whiskerprops=dict(linestyle='-', linewidth=1.5),\n             capprops=dict(linestyle='-', linewidth=1.5),\n             showfliers=False, grid=False, rot=0);\nplt.title(\"Ln(Price) (Outliers not shown)\")\nplt.show()\n```\n\n#### Answer\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nprint(f\"gdf has {gdf.shape[0]:,.0f} rows.\")\n\n# Notice that we use multiple drop statements --\n# in my opinion this isn't ideal nor is the logic\n# data-driven (beyond the fact that zeroes are a \n# major issue when working with logs).\ngdf.drop(gdf[gdf.price==0].index, axis=0, inplace=True)\ngdf.drop(gdf[gdf.price < 5].index, axis=0, inplace=True)\ngdf.drop(gdf[gdf.price > 1000].index, axis=0, inplace=True)\n\n# Notice use of a numpy function since this is what\n# underpins many elements of pandas\ngdf['lnprice'] = np.log(gdf.price)\n\nprint(f\"gdf now has {gdf.shape[0]:,.0f} rows.\")\nprint(f\"The range of price is {gdf.price.min():,.2f} to {gdf.price.max():,.2f}\")\nprint(f\"The range of ln(price) is {gdf.lnprice.min():,.4f} to {gdf.lnprice.max():,.4f}\")\n\n# And plot\ngdf.price.plot(kind='box', vert=False,\n             color=dict(boxes='r', whiskers='r', medians='r', caps='r'),\n             boxprops=dict(linestyle='-', linewidth=1.5),\n             flierprops=dict(linestyle='-', linewidth=1.5),\n             medianprops=dict(linestyle='-', linewidth=1.5),\n             whiskerprops=dict(linestyle='-', linewidth=1.5),\n             capprops=dict(linestyle='-', linewidth=1.5),\n             showfliers=False, grid=False, rot=0);\nplt.title(\"Price (Outliers not shown)\")\nplt.show()\ngdf.lnprice.plot(kind='box', vert=False,\n             color=dict(boxes='r', whiskers='r', medians='r', caps='r'),\n             boxprops=dict(linestyle='-', linewidth=1.5),\n             flierprops=dict(linestyle='-', linewidth=1.5),\n             medianprops=dict(linestyle='-', linewidth=1.5),\n             whiskerprops=dict(linestyle='-', linewidth=1.5),\n             capprops=dict(linestyle='-', linewidth=1.5),\n             showfliers=False, grid=False, rot=0);\nplt.title(\"Ln(Price) (Outliers not shown)\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngdf has 85,134 rows.\ngdf now has 83,763 rows.\nThe range of price is 7.00 to 1,000.00\nThe range of ln(price) is 1.9459 to 6.9078\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-40-output-2.pdf){fig-pos='H'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-40-output-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\n## Plot Options\n\nNow plot the ln(price) as a chloropleth using:\n\n1. A figure size of 9 x 6\n2. A marker size of 0.25\n3. The Viridis colourmap\n4. A legend\n5. A legend label of 'Natural Log of Price per Night ($)'\n\nI'd suggest [referring to the documentation](https://geopandas.org/mapping.html).\n\n:::: {.qna}\n\n#### Question\n\n```python\nax = gdf.plot(figsize=??, marker='*', markersize=0.25, \n         column=??, cmap=??, \n         legend=??, legend_kwds=??);\nax.set_title(\"Plot of Natural Log of Nightly Price for Airbnb Listings (Outliers Removed)\");\n```\n\n#### Answer\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nax = gdf.plot(figsize=(9,6), marker='*', markersize=0.25,\n         column='lnprice', cmap='viridis',\n         legend=True, legend_kwds={'label':'Natural Log of Price per Night ($)'});\nax.set_title(\"Plot of Natural Log of Nightly Price for Airbnb Listings (Outliers Removed)\");\nf = ax.get_figure()\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-41-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYou should get something like:\n\n::: {.cell execution_count=41}\n\n::: {.cell-output .cell-output-display execution_count=37}\n![Natural Log of Price per Night ($) with Outliers REmoved](Practical-06-Spatial_Data_files/figure-pdf/cell-42-output-1.pdf){}\n:::\n:::\n\n\n## Zooming In/Out\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty Level: Low\n\n:::\n\nThat's a little hard to see, let's try zooming in on Central London! Very roughly, let's call that an Easting range of 525,000 to 535,000 and a Northing range of 178,000 to 185,000.\n\n::: {.callout-tip}\n\n#### Plotting\n\nWe show one way to do this below (`f,ax = plt.subplots(...)`) because it gives you greater control, but `gdf.plot()` *can* return an axis object (`ax = gdf.plot(...)`) that gives you the same kind of access... but with a bit more 'faff'.\n\n:::\n\n:::: {.qna}\n\n#### Question\n\n```python\n# Note this new f,ax syntax and that we then\n# pass ax=ax to gdf.plot -- this has to do with\n# where and how things are plotted.\nf,ax = plt.subplots(1,1,figsize=(9,6))\ngdf.plot(ax=ax, marker='*', markersize=0.25, \n         column='lnprice', cmap='viridis', \n         legend=True, legend_kwds={'label':'Natural Log of Price per Night ($)'});\nax.set_title(\"Ln(Price/Night) for Airbnb Listings (Central London Detail)\")\nax.??\nax.??\nf\n```\n\n#### Answer\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\n# Note this new f,ax syntax and that we then\n# pass ax=ax to gdf.plot -- this has to do with\n# where and how things are plotted.\nf,ax = plt.subplots(1,1,figsize=(9,6))\ngdf.plot(ax=ax, marker='*', markersize=0.25,\n         column='lnprice', cmap='viridis',\n         legend=True, legend_kwds={'label':'Natural Log of Price per Night ($)'});\nax.set_title(\"Ln(Price/Night) for Airbnb Listings (Central London Detail)\")\nax.set_xlim([525000,535000])\nax.set_ylim([178000,185000])\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-43-output-1.pdf){fig-pos='H'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-43-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYour result should look something like this:\n\n::: {.cell execution_count=43}\n\n::: {.cell-output .cell-output-display execution_count=39}\n![Natural Log of Price per Night ($)](Practical-06-Spatial_Data_files/figure-pdf/cell-44-output-1.pdf){}\n:::\n:::\n\n\nThat's a little better, but ideally we'd do more thinking about outliers... \n\n## Changing the Classification Scheme\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty Level: Moderate (mainly computation time)\n\n:::\n\nLet's give this one last try using the quantiles classification scheme for Central London!\n\n:::: {.qna}\n\n#### Question\n\n```python\nf,ax = plt.subplots(1,1,figsize=(9,7))\nax = gdf.plot(marker='*', markersize=0.25, \n         column='lnprice', cmap='viridis', ??, k=5, \n         legend=True, ax=ax); \n         # Note that the legend *label* had to go -- \n         # there are other ways to add it.\n\nax.set_xlim([525000,535000])\nax.set_ylim([178000,185000])\n```\n\n#### Answer\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nf,ax = plt.subplots(1,1,figsize=(9,7))\ngdf.plot(marker='*', markersize=0.25,\n         column='lnprice', cmap='viridis', scheme='quantiles', k=5,\n         legend=True, ax=ax); \n         # Note that the legend *label* had to go -- \n         # there are other ways to add it\n\nax.set_xlim([525000,535000])\nax.set_ylim([178000,185000])\n```\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-45-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYour answer should look like:\n\n::: {.cell execution_count=45}\n\n::: {.cell-output .cell-output-display execution_count=41}\n![Natural Log of Price per Night ($) in Central London](Practical-06-Spatial_Data_files/figure-pdf/cell-46-output-1.pdf){}\n:::\n:::\n\n\n# Simple Web Maps\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty Level: Hard\n\n:::\n\nThis is more for the sake of demonstrating Python's features than because it's part of my workflow, but what the heck, let's do it! We will create and embed a zoomable web map in the notebook; to do _that_ we need to:\n\n1. Calculate the bounds of the map using the min/max x and y coordinates above.\n2. Calculate the centroid of the map from the bounds.\n3. Set an appropriate zoom level.\n\nIf your work is going well, perhaps you may also want to experiment with [different basemaps](https://ipyleaflet.readthedocs.io/en/latest/api_reference/basemaps.html).\n\n::: {.callout-tip}\n\nYou can't use `round` here because it it could round up or down depending on what's closest and, consequently, cut off data on your map. So you'll have to look for two *other* functions that do this predictably (e.g. always rounding down, even if the value is 4.999999). However, those functions don't handle decimals like `round` does, so you need to think about how you could turn a number like 4.99 into a number that those functions *can* work with and then turn it *back* into the decimal...\n\n:::\n\n:::: {.qna}\n\n#### Question\n\n```python\nfrom math import floor, ceil\n\n# Calculate min and max to *two* decimal places\nxmin = ??\nxmax = ??\nymin = ??\nymax = ??\n\n# Print them to *3* decimal places to check they end in 0\nprint(f\"{xmin:.3f}, {xmax:.3f}, {ymin:.3f}, {ymax:.3f}\")\n\n# Calculate the centre of the map\nyctr = ??\nxctr = ??\n\n# Print this two ways to see an intriguing issue\nprint(f\"{xctr:.5f}, {yctr:.5f}\")\nprint(xctr, yctr)\n```\n\nYou should end up with something like: \n```\n-0.530, 0.310, 51.270, 51.710\n-0.11000, 51.49000\n-0.10999999999999999 51.49\n```\nYou'll see *why* this happens in the answer.\n\n#### Answer\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nfrom math import floor, ceil\n\n# Calculate min and max to *two* decimal places\nxmin = floor(df.longitude.min()*100)/100\nxmax = ceil(df.longitude.max()*100)/100\nymin = floor(df.latitude.min()*100)/100\nymax = ceil(df.latitude.max()*100)/100\n\n# Print them to *3* decimal places to check they end in 0\nprint(f\"{xmin:.3f}, {xmax:.3f}, {ymin:.3f}, {ymax:.3f}\")\n\n# Calculate the centre of the map\nyctr = ymin+(ymax-ymin)/2\nxctr = xmin+(xmax-xmin)/2\n\n# Print this two ways to see an intriguing issue\nprint(f\"{xctr:.5f}, {yctr:.5f}\")\nprint(xctr, yctr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-0.500, 0.300, 51.290, 51.690\n-0.10000, 51.49000\n-0.09999999999999998 51.489999999999995\n```\n:::\n:::\n\n\n::::\n\nIf you've managed the calculations above, then this code should simply run!\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nfrom ipyleaflet import Map, basemaps, basemap_to_tiles, Rectangle, projections\n\n# Note the basemap can be easily changed\nwatercolor = basemap_to_tiles(basemaps.OpenStreetMap.HOT)\n\nm = Map(layers=(watercolor, ), center=(yctr, xctr), zoom=8)\n\nrectangle = Rectangle(bounds=( (ymin, xmin), (ymax, xmax) ),\n    crs=projections.EPSG4326\n)\n\nm.add_layer(rectangle)\n\nm\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\nMap(center=[51.489999999999995, -0.09999999999999998], controls=(ZoomControl(options=['position', 'zoom_in_tex…\n```\n:::\n:::\n\n\nYour map should look like this:\n\n::: {.cell execution_count=48}\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\nMap(center=[51.489999999999995, -0.09999999999999998], controls=(ZoomControl(options=['position', 'zoom_in_tex…\n```\n:::\n:::\n\n\n# Bringing it All Together\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty Level: &#129327;\n\n:::\n\nTo give a bit of a show of how we can put it all together try to get this working\n\n:::: {.qna}\n\n#### Question\n\n```python\nimport pysal as p\nimport mapclassify as mc\nimport palettable.matplotlib as palmpl\nfrom legendgram import legendgram\n\n# We create a temporary data frame here because we want\n# the 'bins' to be created using only the data on the \n# map. Otherwise, we'd have a distribution on the map \n# that differed from the one in the legendgram and the\n# one used to calculate the breaks in the first place!\ntgdf = gdf[(gdf.geometry.x > 525000) & (gdf.geometry.x < 540000) & (gdf.geometry.y > 176000) & (gdf.geometry.y < 186000)].copy()\n\n# Here we use Mapclassify to calculate quantiles\n# (k=5) using the original price. You could use\n# any Mapclassify scheme at this point, though\n# note that for Fisher Jenks you might want to use\n# the 'Sampled' version to speed things up a bit.\nq = mc.??(tgdf.price.values, ??)\n\n# We then write these binned values *back* on to the data\n# frame so that we can use them with the GDF plot function.\ntgdf['bins'] = q.??\n\n# Set up the figure with its 'basemap'\nf,ax = plt.subplots(figsize=(10,6))\ngreen.plot(edgecolor=(0.7, 0.7, 0.14, 0.25), facecolor=(0.7, 0.7, 0.14, 0.25), zorder=1, ax=ax)\nwater.plot(edgecolor=\"none\", facecolor='xkcd:lightblue', zorder=2, ax=ax)\nboros.plot(edgecolor=(0.8, 0, 0, 0.5), facecolor='none', linewidth=2.5, zorder=3, ax=ax)\n\n# Restrict the x and y axis to the data\n# Notice it's hard-coded here *and* above\n# this could be done *better* using a \n# custom bounding box so that we could \n# update both the tgdf and the display\n# area at the same time.\nax.set_xlim([525000,540000])\nax.set_ylim([176000,186000])\n\nax.axis(??) # Don't plot the axes\n\n# Plot the bins using a categorical legend instead\n# of the price using a continuous legend.\ntgdf.plot(column='bins', categorical=True,\n         cmap='viridis', legend=True, marker='.', markersize=1.5, zorder=4, ax=ax)\n\n# Set the title using a specified font, weight, and size\nax.set_title('London Airbnb Listings Price Per Night', \n             fontdict={'fontsize':'20', 'fontweight':'3', 'family':fontname})  #provide a title\n\n# This is where geopandas gets in the way -- the \n# categorical legend doesn't work for us so we need\n# to actually create the legend 'by hand' using this \n# code... which first has to *find* the layer containing\n# the data! Each layer is a 'patch collection', so we \n# loop through the collections looking for the one whose\n# z-order is 4 (which we set above to the data layer).\n#\n# I relied on this: https://stackoverflow.com/a/71419387/4041902\n# to work out how to do this!\nfor c in ax.collections:\n    # Find the layer with the data\n    if c.get_zorder()==4:\n        # *Now* we can create a legend... but we need to \n        # first retrieve the colours from the layer. These\n        # are returned as 'handles' and then we need to \n        # associate these with the labels taken from the\n        # Mapclassify object... Once we set that up, along\n        # with fonts and such, we can add it as an 'artist'\n        # to the figure.\n        handles, _ = c.legend_elements(prop=\"colors\")\n        legend1 = ax.legend(handles, q.get_legend_classes(fmt='{:.2f}'), \n                            loc=\"upper right\", title=\"Price per Night\", \n                            prop={'size':'10', 'weight':'1', 'family':fontname})\n        ax.add_artist(legend1)\n\n# And don't forget to add a source!\na = ax.text(tgdf.geometry.x.max(), tgdf.geometry.y.min(), 'Source: InsideAirbnb (2022)', \n             horizontalalignment='right', verticalalignment='bottom', \n             fontsize=14, fontweight=4, color='#333333', family=fontname)\n\n# And this is a nice feature: show the distribution!\nax2 = legendgram(f, ax, \n           tgdf.??, q.??, bins=round(gdf.price.max()/25),\n           pal=palmpl.Viridis_5,\n           legend_size=(0.3, 0.1), \n           loc='lower left',\n           clip=(0,1000),\n           frameon=True\n    )\n# But we have to fix the font manually here\n# for the legendgram too\nfor tk in ax2.get_xticklabels():\n    tk.set_fontname(fontname)\n    \n#plt.savefig('Airbnb-price-all.png', dpi=150)\n```\n\n#### Answer\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\nimport pysal as p\nimport mapclassify as mc\nimport palettable.matplotlib as palmpl\nfrom legendgram import legendgram\n\n# We create a temporary data frame here because we want\n# the 'bins' to be created using only the data on the\n# map. Otherwise, we'd have a distribution on the map\n# that differed from the one in the legendgram and the\n# one used to calculate the breaks in the first place!\ntgdf = gdf[(gdf.geometry.x > 525000) & (gdf.geometry.x < 540000) & (gdf.geometry.y > 176000) & (gdf.geometry.y < 186000)].copy()\n\n# Here we use Mapclassify to calculate quantiles\n# (k=5) using the original price. You could use\n# any Mapclassify scheme at this point, though\n# note that for Fisher Jenks you might want to use\n# the 'Sampled' version to speed things up a bit.\nq = mc.Quantiles(tgdf.price.values, k=5)\n\n# We then write these binned values *back* on to the data\n# frame so that we can use them with the GDF plot function.\ntgdf['bins'] = q.yb\n\n# Set up the figure with its 'basemap'\nf,ax = plt.subplots(figsize=(10,6))\ngreen.plot(edgecolor=(0.7, 0.7, 0.14, 0.25), facecolor=(0.7, 0.7, 0.14, 0.25), zorder=1, ax=ax)\nwater.plot(edgecolor=\"none\", facecolor='xkcd:lightblue', zorder=2, ax=ax)\nboros.plot(edgecolor=(0.8, 0, 0, 0.5), facecolor='none', linewidth=2.5, zorder=3, ax=ax)\n\n# Restrict the x and y axis to the data\n# Notice it's hard-coded here *and* above\n# this could be done *better* using a\n# custom bounding box so that we could\n# update both the tgdf and the display\n# area at the same time.\nax.set_xlim([525000,540000])\nax.set_ylim([176000,186000])\n\nax.axis('off') # Don't plot the axes\n\n# Plot the bins using a categorical legend instead\n# of the price using a continuous legend.\ntgdf.plot(column='bins', categorical=True,\n         cmap='viridis', legend=True, marker='.', markersize=1.5, zorder=4, ax=ax)\n\n# Set the title using a specified font, weight, and size\nax.set_title('London Airbnb Listings Price Per Night',\n             fontdict={'fontsize':'20', 'fontweight':'3', 'family':fontname})  #provide a title\n\n# This is where geopandas gets in the way -- the\n# categorical legend doesn't work for us so we need\n# to actually create the legend 'by hand' using this\n# code... which first has to *find* the layer containing\n# the data! Each layer is a 'patch collection', so we\n# loop through the collections looking for the one whose\n# z-order is 4 (which we set above to the data layer).\n#\n# I relied on this: https://stackoverflow.com/a/71419387/4041902\n# to work out how to do this!\n\nfor c in ax.collections:\n    # Find the layer with the data\n    if c.get_zorder()==4:\n        # *Now* we can create a legend... but we need to\n        # first retrieve the colours from the layer. These\n        # are returned as 'handles' and then we need to\n        # associate these with the labels taken from the\n        # Mapclassify object... Once we set that up, along\n        # with fonts and such, we can add it as an 'artist'\n        # to the figure.\n        handles, _ = c.legend_elements(prop=\"colors\")\n        legend1 = ax.legend(handles, q.get_legend_classes(fmt='{:.2f}'),\n                            loc=\"upper right\", title=\"Price per Night\",\n                            prop={'size':'10', 'weight':'1', 'family':fontname})\n        ax.add_artist(legend1)\n\n# And don't forget to add a source!\na = ax.text(tgdf.geometry.x.max(), tgdf.geometry.y.min(), 'Source: InsideAirbnb (2022)',\n             horizontalalignment='right', verticalalignment='bottom',\n             fontsize=14, fontweight=4, color='#333333', family=fontname)\n\n# And this is a nice feature: show the distribution!\nax2 = legendgram(f, ax,\n           tgdf.price, q.bins, bins=round(gdf.price.max()/25),\n           pal=palmpl.Viridis_5,\n           legend_size=(0.3, 0.1),\n           loc='lower left',\n           clip=(0,1000),\n           frameon=True\n    )\n# But we have to fix the font manually here\n# for the legendgram too\nfor tk in ax2.get_xticklabels():\n    tk.set_fontname(fontname)\n\n#plt.savefig('Airbnb-price-all.png', dpi=150)\nf\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-50-output-1.pdf){fig-pos='H'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](Practical-06-Spatial_Data_files/figure-pdf/cell-50-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n::::\n\nYou should have something like this:\n\n::: {.cell execution_count=50}\n\n::: {.cell-output .cell-output-display execution_count=46}\n![London Airbnb Listings Price Per Night (Quantiles)](Practical-06-Spatial_Data_files/figure-pdf/fig-price-quantiles-output-1.pdf){#fig-price-quantiles}\n:::\n:::\n\n\nI'll be honest, I do find ggplot easier for making good-quality; this _is_ more customisable overall, but it's also much more 'magical' in the sense of 'search for `matplotlib` examples that do what you want then copy+paste them and tweak' being the main way that most people get things working how they want.\n\nScalebars are awkward, and there's now a library that can help with this [on GitHub](https://github.com/ppinard/matplotlib-scalebar) that I've installed. But I'll leave that one to you.\n\n::: {.callout-tip}\nYou can find a lot of *possible* solutions in [this Stackoverflow thread](https://stackoverflow.com/questions/32333870/how-can-i-show-a-km-ruler-on-a-cartopy-matplotlib-plot) that *should* work without needing to install new libraries but I've not had a chance to test them each individually. You would undoubtedly want to put this in an external package and import it when needed rather than paste this code into every file. But you might find it easier to *test* the solutions by pasting. If you're looking for glory (and my gratitude) then working out which of these is most generalisable (i.e. would work with both lat/long *and* OSGB coordinates) would be quite the challenge!\n\n:::\n\n### Getting More Help/Applications\n\nA great resource for more help and more examples is Dani Arribas-Bel's _Geographic Data Science_ module: he has put all of his [module practicals online](https://github.com/darribas/gds_course) (as we have too), and you might find that something that he does makes more sense to you than what we've done... check it out!\n\n## Credits!\n\n#### Contributors:\nThe following individuals have contributed to these teaching materials: Jon Reades (j.reades@ucl.ac.uk), James Millington (james.millington@kcl.ac.uk)\n\n#### License\nThese teaching materials are licensed under a mix of [The MIT License](https://opensource.org/licenses/mit-license.php) and the [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 license](https://creativecommons.org/licenses/by-nc-sa/4.0/).\n\n#### Acknowledgements:\nSupported by the [Royal Geographical Society](https://www.rgs.org/HomePage.htm) (with the Institute of British Geographers) with a Ray Y Gildea Jr Award.\n\n#### Potential Dependencies:\nThis notebook may depend on the following libraries: geopandas, pandas, matplotlib, seaborn\n\n",
    "supporting": [
      "Practical-06-Spatial_Data_files"
    ],
    "filters": []
  }
}
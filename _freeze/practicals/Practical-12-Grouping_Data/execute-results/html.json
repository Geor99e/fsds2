{
  "hash": "46dd49d93774d11fb95a7742c6394663",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Practical 9: Grouping Data\"\nsubtitle: \"Aggregation, Classification & Clustering\"\njupyter: python3\nfilters:\n  - qna\n  - quarto\n---\n\n\n| Complete | Part 1: Foundations | Part 2: Data | Part 3: Analysis |     |\n| :------- | :------------------ | :----------- | :--------------- | --: |\n| 80% | &#9619;&#9619;&#9619;&#9619;&#9619;&#9619;&#9619;&#9619; | &#9619;&#9619;&#9619;&#9619;&#9619;&#9619; | &#9619;&#9619;&#9619;&#9617;&#9617;&#9617; | 9/10\n\nA common challenge in data analysis is how to group observations in a data set together in a way that allows for generalisation: _this_ group of observations are similar to one another, _that_ group is dissimilar to this group. Sometimes we have a *label* that we can use as part of the process (in which case we're doing **classification**), and somtimes we don't (in which case we're doing **clustering**). But what defines similarity and difference? There is no _one_ answer to that question and so there are many different ways to cluster or classify data, each of which has strengths and weaknesses that make them more, or less, appropriate in different contexts.\n\n::: {.callout-note}\n\n    **&#128279; Connections**: This practical pulls together many topics covered in other modules, and many of the ideas covered elsewhere in _this_ module: clustering, reproducibility, dimensionality reduction... but, above all, this practical is about the importance of **judgement**. Do _not_ take what we've done here as the ONE RIGHT WAY: a number of these results are questionnable at best because we haven't developed or defined an underlying hypothesis informed by a critical appraisal of the data. You should be _much_ more selective in how you deploy the data and the algorithms, as last week's [session on dimensionality](https://jreades.github.io/fsds/sessions/week8.html) should have shown.\n    \n:::\n\n# Preamble\n\n```python\nimport warnings # This suppresses some meaningless errors from Seaborn and Pandas\nwarnings.simplefilter(action='ignore', category=FutureWarning)\n```\n\n```python\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport matplotlib as mpl\nimport re\nimport os\n\nfrom matplotlib.colors import ListedColormap\n\n# All of these are potentially useful, though\n# not all have been used in this practical --\n# I'd suggest exploring the use of different \n# Scalers/Transformers as well as clustering \n# algorithms...\nfrom sklearn.neighbors import NearestNeighbors\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import MinMaxScaler, StandardScaler, RobustScaler, PowerTransformer\nfrom sklearn.cluster import KMeans, DBSCAN, OPTICS\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import silhouette_samples, silhouette_score\n\nimport random\nrandom.seed(42)    # For reproducibility\nnp.random.seed(42) # For reproducibility\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))\n```\n\n### Initialise the Scaler(s)\n\nRemember that you can set up the `sklearn` transformers in advance, and then `fit` them before `transform`-ing them.\n\n```python\nmms  = MinMaxScaler(feature_range=(-1,1))\nstds = StandardScaler()\nrbs  = RobustScaler()\npts  = PowerTransformer()\n```\n\n### Set Up Plotting Functions\n\n::: {.callout-note}\n\n    **&#128279; Connections**: Here's an example of how you can use a function to do something a little more complex than just locally save some data. This is still largely a kind of 'stub', but if you are going to be producing a lot of plots of London why not automate away some of the pain of producing a good-looking basemap _each_ time: use a function to apply the formatting and then just return `f` and `ax` as if you'd done this all yourself.\n\n:::\n\n```python\ndef plt_ldn(w, b):\n    \"\"\"\n    Creates a new figure of a standard size with the \n    water (w) and boundary (b) layers set up for easy\n    plotting. Right now this function assumes that you're\n    looking at London, but you could parameterise it in\n    other ways ot allow it to work for other areas.\n    \n    w: a water layer for London\n    b: a borough (or other) boundary layer for London\n    \"\"\"\n    fig, ax = plt.subplots(1, figsize=(14, 12))\n    w.plot(ax=ax, color='#79aef5', zorder=2)\n    b.plot(ax=ax, edgecolor='#cc2d2d', facecolor='None', zorder=3)\n    ax.set_xlim([502000,563000])\n    ax.set_ylim([155000,201500])\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    return fig, ax\n\n########################\n# These may no longer be relevant because of changes to geopandas API\n\ndef default_cmap(n, outliers=False):\n    cmap = mpl.cm.get_cmap('viridis_r', n)\n    colors = cmap(np.linspace(0,1,n))\n    if outliers:\n        gray = np.array([225/256, 225/256, 225/256, 1])\n        colors = np.insert(colors, 0, gray, axis=0)\n    return ListedColormap(colors)\n\n# mappable = ax.collections[-1] if you add the geopandas\n# plot last.\ndef add_colorbar(mappable, ax, cmap, norm, breaks, outliers=False):\n    cb = fig.colorbar(mappable, ax=ax, cmap=cmap, norm=norm,\n                    boundaries=breaks,\n                    extend=('min' if outliers else 'neither'), \n                    spacing='uniform',\n                    orientation='horizontal',\n                    fraction=0.05, shrink=0.5, pad=0.05)\n    cb.set_label(\"Cluster Number\")\n```\n\n### Set up Caching Function\n\n```python\nimport os\nfrom requests import get\nfrom urllib.parse import urlparse\n\ndef cache_data(src:str, dest:str) -> str:\n    \"\"\"Downloads and caches a remote file locally.\n    \n    The function sits between the 'read' step of a pandas or geopandas\n    data frame and downloading the file from a remote location. The idea\n    is that it will save it locally so that you don't need to remember to\n    do so yourself. Subsequent re-reads of the file will return instantly\n    rather than downloading the entire file for a second or n-th itme.\n    \n    Parameters\n    ----------\n    src : str\n        The remote *source* for the file, any valid URL should work.\n    dest : str\n        The *destination* location to save the downloaded file.\n        \n    Returns\n    -------\n    str\n        A string representing the local location of the file.\n    \"\"\"\n    \n    url = urlparse(src) # We assume that this is some kind of valid URL \n    fn  = os.path.split(url.path)[-1] # Extract the filename\n    dfn = os.path.join(dest,fn) # Destination filename\n    \n    # Check if dest+filename does *not* exist -- \n    # that would mean we have to download it!\n    if not os.path.isfile(dfn) or os.path.getsize(dfn) < 1:\n        \n        print(f\"{dfn} not found, downloading!\")\n\n        # Convert the path back into a list (without)\n        # the filename -- we need to check that directories\n        # exist first.\n        path = os.path.split(dest)\n        \n        # Create any missing directories in dest(ination) path\n        # -- os.path.join is the reverse of split (as you saw above)\n        # but it doesn't work with lists... so I had to google how\n        # to use the 'splat' operator! os.makedirs creates missing\n        # directories in a path automatically.\n        if len(path) >= 1 and path[0] != '':\n            os.makedirs(os.path.join(*path), exist_ok=True)\n            \n        # Download and write the file\n        with open(dfn, \"wb\") as file:\n            response = get(src)\n            file.write(response.content)\n            \n        print('Done downloading...')\n\n    else:\n        print(f\"Found {dfn} locally!\")\n\n    return dfn\n```\n\n# Load Data\n\n## London Data Layers\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\n```python\nspath = 'https://github.com/jreades/fsds/blob/master/data/src/' # source path\nddir  = os.path.join('data','geo') # destination directory\nwater = gpd.read_file( cache_data(spath+'Water.gpkg?raw=true', ddir) )\nboros = gpd.read_file( cache_data(spath+'Boroughs.gpkg?raw=true', ddir) )\ngreen = gpd.read_file( cache_data(spath+'Greenspace.gpkg?raw=true', ddir) )\n\nmsoas = gpd.read_file( cache_data('http://orca.casa.ucl.ac.uk/~jreades/data/MSOA-2011.gpkg', ddir) )\nmsoas = msoas.to_crs(epsg=27700)\n\n# I don't use this in this practical, but it's a\n# really useful data set that gives you 'names'\n# for MSOAs that broadly correspond to what most\n# Londoners would think of as a 'neighbourhood'.\nmsoa_nms = gpd.read_file( cache_data('http://orca.casa.ucl.ac.uk/~jreades/data/MSOA-2011-Names.gpkg', ddir) )\nmsoa_nms = msoa_nms.to_crs(epsg=27700)\nprint(\"Done.\")\n```\n\n## Reduced Dimensionality MSOA Data\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\nYou should have this locally from last week, but just in case...\n\n```python\nhost = 'http://orca.casa.ucl.ac.uk'\npath = '~jreades/data'\nrddf = gpd.read_parquet( cache_data(f'{host}/{path}/Reduced_Dimension_Data.geoparquet', ddir) )\nprint(f\"Data frame is {rddf.shape[0]:,} x {rddf.shape[1]}\")\n```\n\nYou should have: `Data frame is 983 x 93`.\n\nAnd below you should see both the components and the dimensions from last week's processing.\n\n```python\nrddf.iloc[0:3, -7:]\n```\n\nI get the results below, but note that the **Dimension values** may be slightly different:\n\n|        | Component 5 | Component 6 | Component 7 | Borough | Dimension 1 | Dimension 2 | Subregion |\n| :------| ----------: | -----------:| ----------: | ------: | ----------: | ----------: | --------: |\n| **E02000001** | 1.44 | 3.95 | -1.52 | City of London | 7.74 | 3.36 | Inner West |\n| **E02000002** | -0.28 | 0.89 | 0.26 | Barking and Dagenham | 2.04 | 7.59 | Outer East and North East |\n| **E02000003** | -0.11 | 1.12 | 0.83 | Barking and Dagenham | 2.20 | 6.87 | Outer East and North East |\n\n## Listings Data\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\nLet's also get the listings data from a few weeks back:\n\n```python\nlistings = gpd.read_parquet( cache_data(f'{host}/{path}/2023-09-06-listings.geoparquet', ddir) )\nlistings = listings.to_crs(epsg=27700)\nprint(f\"Data frame is {listings.shape[0]:,} x {listings.shape[1]}\")\n```\n\nYou should have: `Data frame is 85,134 x 31`.\n\nAnd a quick plot of the price to check:\n\n```python\nlistings.plot(???, cmap='plasma', scheme='quantiles', k=10, \n              markersize=.5, alpha=0.15, figsize=(10,7));\n```\n\n# Aggregate Listings by MSOA\n\n## Join Listings to MSOA\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Medium-to-hard.\n\n:::\n\nFirst, let's link all this using the MSOA Geography that we created last week and a mix or merge and sjoin!\n\n::: {.callout-note}\n\n    **&#128279; Connections**: Notice a few things going on here! We are calling `gpd.sjoin` because pandas (`pd`) doesn't know about spatial joins, only geopandas (`gpd`) does. More on this [next week](https://jreades.github.io/fsds/sessions/week10.html#lectures). Also see how we drop some columns _at the point where we do the join_ by taking advantage of the fact that most pandas/geopandas operations return a _copy_ of the (Geo)DataFrame. That allows us to get back from the spatial join a neat, tidy data frame ready for further analysis. If you're struggling to make sense of this, try removing the `drop` operations and see what your data frame looks like afterwards. This should all be old hat, but in case you need a refresher there's always [Week 5](https://jreades.github.io/fsds/sessions/week5.html) on pandas.\n:::\n\n```python\n# Before the spatial join\nlistings.columns\n```\n\n```python\nmsoa_listings = gpd.sjoin(???, msoas.drop(\n                        columns=['MSOA11NM', 'LAD11CD', 'LAD11NM', 'RGN11CD', 'RGN11NM',\n                                 'USUALRES', 'HHOLDRES', 'COMESTRES', 'POPDEN', 'HHOLDS', \n                                 'AVHHOLDSZ']), predicate='???').drop(\n                        columns=['latitude','longitude','index_right']\n                )\n```\n\n```python\n# All we've added is the MSOA11CD\nmsoa_listings.columns\n```\n\nAll being well you should now have:\n\n```\nIndex(['listing_url', 'last_scraped', 'name', 'description', 'host_id',\n       'host_name', 'host_since', 'host_location', 'host_is_superhost',\n       'host_listings_count', 'host_total_listings_count',\n       'host_verifications', 'property_type', 'room_type', 'accommodates',\n       'bathrooms_text', 'bedrooms', 'beds', 'amenities', 'price',\n       'minimum_nights', 'maximum_nights', 'availability_365',\n       'number_of_reviews', 'first_review', 'last_review',\n       'review_scores_rating', 'reviews_per_month', 'geometry', 'MSOA11CD'],\n      dtype='object')\n```\n\n## Price by MSOA \n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Medium.\n\n:::\n\nLet's calculate the median price by MSOA... Notice that we have to specify the column we want after the `groupby` so the we don't get the median of *every* column returned\n\n::: {.callout-note}\n\n    **&#128279; Connections**: I find `groupby` to be a complex operation and often need a couple of gos before I get back waht I want. The thing to take away is that: 1) anything in the `groupby` will become part of the `index` afterwards (so if you group on multiple things you get a multi-part index); 2) aggregating functions apply to _all_ columns unless you filter them some way. Here we filter by selecting only the `price` column to aggregate. You can also filter for `numeric only`.\n:::\n\n```python\n# *m*soa *l*istings *g*rouped by *p*rice\nmlgp = msoa_listings.groupby('???')['price'].agg('???') \nmlgp.head()\n```\n\nYou should get something like:\n\n```\nMSOA11CD\nE02000001   170.00\nE02000002    97.00\nE02000003    80.00\nE02000004    54.00\nE02000005   100.00\nName: price, dtype: float64\n```\n\n## Room Type by MSOA\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Medium.\n\n:::\n\nNow let's calculate the count of room types by MSOA and compare the effects of `reset_index` on the outputs below. And notice too that we can assign the aggregated value to a column name!\n\n```python\n# *m*soa *l*istings *g*rouped *c*ount\nmlgc = msoa_listings.groupby(['???','???'], observed=False).listing_url.agg(Count='???')\nmlgc.head()\n```\n\nYou should get something resembling this:\n\n| MSOA11CD | room_type | Count<br/>&nbsp;<br />&nbsp; |\n| -------: | :-------- | --: |\n| **E02000001** | **Entire home/apt** | 466 |\n|  | **Hotel room** | 0 |\n|  | **Private room** | 61 |\n|  | **Shared room** | 1 |\n| **E02000002** | **Entire home/apt** | 4 |\n\n```python\n# *m*soa *l*istings *g*rouped *c*ount *r*eset index\nmlgcr = msoa_listings.groupby(['???','???'], observed=False).listing_url.agg(Count='???').reset_index() # msoa listings grouped counts\nmlgcr.head()\n```\n\nYou should get something like: \n\n|    | MSOA11CD | room_type | Count |\n| -: | :------- | :-------- | ----: |\n| 0 | E02000001 | Entire home/apt | 466 |\n| 1 | E02000001 | Hotel room | 0 |\n| 2 | E02000001 | Private room | 61 |\n| 3 | E02000001 | Shared room | 1 |\n| 4 | E02000002 | Entire home/apt | 4 |\n\n## Price by Room Type\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty: Hard.\n\n:::\n\nBut perhaps median price/room type would make more sense? And do we want to retain values where there are no listings? For example, there are no hotel rooms listed for E02000001, how do we ensure that these *NAs are dropped*?\n\n```python\n# *m*soa *l*istings *g*rouped *r*oom *p*rice\nmlgrp = msoa_listings.???(???, observed=True\n                      )['price'].agg('???').reset_index()\nmlgrp.head()\n```\n\nYou should get something like:\n\n|    | MSOA11CD | room type | price |\n| -: | :------- | :-------  | ----: |\n| 0 | E02000001 | Entire home/apt | 177.00 |\n| 2 | E02000001 | Private room | 100.00 |\n| 3 | E02000001 | Shared room | 120.00 |\n| 4 | E02000002 | Entire home/apt | 117.00 |\n| 6 | E02000002 | Private room | 42.00 |\n\n## Explore Outlier Per-MSOA Prices\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Medium.\n\n:::\n\nAre there MSOAs what *look* like they might contain erroneous data?\n\n### Plot MSOA Median Prices\n\n```python\nmlgp.hist(bins=200);\n```\n\n### Examine Listings from High-Priced MSOAs\n\nCareful, this is showing the *listings* from MSOAs whose median price is above $300/night:\n\n```python\nmsoa_listings[\n    msoa_listings.MSOA11CD.isin(mlgp[mlgp > 300].index)\n].sort_values(by='price', ascending=False).head(7)[\n    ['price','room_type','name','description']\n]\n```\n\nSome of these look legi (4, 5, and... 8 bedroom 'villas'?), though not every one...\n\nAnd how about these?\n\n```python\nmsoa_listings[\n    (msoa_listings.MSOA11CD.isin(mlgp[mlgp > 300].index)) & (msoa_listings.room_type!='Entire home/apt')\n].sort_values(by='price', ascending=False).head(7)[\n    ['price','room_type','property_type','name','description']\n]\n```\n\nIf we wanted to be rigorous then we'd have to investigate further: properties in Mayfair and Westminster *are* going to be expensive, but are these plausible nightly prices? In some cases, yes. In others...\n\n```python\nmsoa_listings[\n    (msoa_listings.MSOA11CD.isin(mlgp[mlgp < 100].index)) & (msoa_listings.room_type!='Entire home/apt')\n].sort_values(by='price', ascending=False).head(7)[\n    ['price','room_type','name','description']\n]\n```\n\nOn the whole, let's take a *guess* that there are a small number of implausibly high prices for individual units that aren't in very expensive neighbourhoods and that these are either erroneous/deliberately incorrect, or represent a price that is not per-night. \n\n::: {.callout-note}\n\n    **&#128279; Connections**: What's the right answer here? There isn't one. You could probably spend _months_ figuring out what's a real, available-to-let listing and waht isn't. I would argue that assuming all listings are 'legit' without doing some additional EDA and ESDA is negligent. You could also look at how some of the methods of standardisation/normalisation work and use those to identify improbable listings (but remember that a £10,000 in Mayfair _might_ be legit, while a $5,000 listing in Barking _probably_ isn't!). Or you could look at the inter-decile range (or just define your own range: 1%-99%?).\n:::\n\n### Filter Unlikely Listings\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty: Hard.\n\n:::\n\nSee if you can filter out these less likely listings on the following criteria:\n\n1. Listings are priced above $300/night AND\n2. Room type is not `'Entire home/apt'` AND\n3. Listings do *not* contain the words: suite, luxury, loft, stunning, prime, historic, or deluxe.\n\nI found 901 rows to drop this way.\n\n```python\ntarget_regex = r'(?:suite|luxury|loft|stunning|prime|historic|deluxe|boutique)'\nto_drop = msoa_listings[\n            (???) & \n            (???) &\n            ~(???(target_regex, flags=re.IGNORECASE, regex=True, na=True))]\nprint(f\"Have found {to_drop.shape[0]:,} rows to drop on the basis of unlikely per night prices.\")\n```\n\n```python\nto_drop.sort_values(by='price', ascending=False)[['price','room_type','name','description']]\n```\n\n### Plot Unlikely Listings\n\nHere we use the `plt_ldn` function -- notice how it's designed to return `f,ax` in the same way that `plt.subplots` (which we're already familiar with) does!\n\n```python\nf,ax = plt_ldn(???, ???)\nto_drop.plot(column='price', markersize=10, alpha=0.7, cmap='viridis', ax=ax);\n```\n\n### ... And Drop\n\nSome might be legitimate, but I'm feeling broadly ok with the remainder.\n\n```python\ncleaned = msoa_listings.drop(index=to_drop.???)\nprint(f\"Cleaned data has {cleaned.shape[0]:,} rows.\")\n```\n\nAfter this I had 84,308 rows.\n\nI would normally, at this point, spend quite a bit of time validating this cleaning approach, but right now we're going to take a rough-and-ready approach.\n\n### Questions\n\n- What data type did [Task 2.2](#Task-2.2:-Price-by-MSOA) return?\n\n> \n\n- What is the function of `reset_index()` in [Task 2.3](#Task-2.:3-Room-Type-by-MSOA) and when might you choose to reset (or not)?\n\n> \n\n# Pivot Tables & 'Wide Data'\n\nThe `group_by` operation is *one* way to organise and aggregate our data, but pivot tables are a *second* common way to achieve this. We typically use a pivot table to go from long to wide data frames -- it's often seen as one of Excel's main benefits, but Pandas can do that too!\n\n::: {.callout-note}\n\n    **&#128279; Connections**: Notice that a pivot table is just a different kind of aggregation. Principally, it's about going from long to wide in your data frame. These issues should be familiar from R and it's `mutate` and other `data.table` methods. We just write them different in Python.\n:::\n\n## Create Pivot Table\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty: Hard.\n\n:::\n\nWe can make use of the pivot table function to generate counts by MSOA in a 'wide' format.\n\n```python\npivot = cleaned.groupby(\n                ['MSOA11CD','room_type'], observed=False\n        ).listing_url.agg(Count='count').reset_index().pivot(\n                index='???', columns=['???'], values=['???'])\npivot.head(3)\n```\n\nThe formatting will look a tiny bit different, but you should get something like this: \n\n|    |          |       |       |       | Count |\n| -: | -------: | ----: | ----: | ----: | ----: |\n| **room_type** | **Entire home/apt** | **Hotel room** | **Private room** | **Shared room** |\n| **MSOA11CD** |  |  |  |  |  | \n| **E02000001** | 466 | 0 | 55 | 1 | \n| **E02000002** | 4 | 0 | 2 | 0 |\n| **E02000003** | 12 | 0 | 13 | 0 |\n\n## Check Counts\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\n```python\npivot.sum()\n```\n\nJust to reassure you that the pivot results 'make sense':\n\n```python\nprint(cleaned[cleaned.room_type=='Entire home/apt'].listing_url.count())\nprint(cleaned[cleaned.room_type=='Private room'].listing_url.count())\n```\n\n## Tidy & Normalise\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\nMy instinct at this point is that, looking at the pivot table, we see quite different levels of Airbnb penetration and it is hard to know how handle this difference: share would be unstable because of the low counts in some places and high counts in others; a derived variable that tells us something about density or mix could be interesting (e.g. HHI or LQ) but wouldn't quite capture the pattern of mixing.\n\n### Tidy\n\nPersonally, based on the room type counts above I think we can drop Hotel Rooms and Shared Rooms from this since the other two categories are *so* dominant.\n\n```python\n# Flatten the column index\npivot.columns = ['Entire home/apt','Hotel room','Private room','Shared room']\n# Drop the columns\npivot.drop(???, inplace=True)\npivot.head()\n```\n\nYou should have only the **Entire home/apt** and **Private room** columns now.\n\n### Normalise\n\n```python\npivot_norm = pd.DataFrame(index=pivot.index)\nfor c in pivot.columns.to_list():\n    # Power Transform\n    pivot_norm[c] = pts.???(pivot[c].to_numpy().reshape(???,???))\n\npivot_norm.head()\n```\n\nYou should have something like:\n\n|          | Entire home/apt | Private room |\n| :------- | --------------: | -----------: |\n| **MSOA11CD** |  |  |\n| **E02000001** | 2.20 | 1.06 |\n| **E02000002** | -1.29 | -1.85 |\n\n### Plot\n\n```python\npnm = pd.merge(msoas.set_index('MSOA11CD'), pivot_norm, left_index=True, right_index=True)\npnm.plot(column='Entire home/apt', cmap='viridis', edgecolor='none', legend=True, figsize=(12,8));\n```\n\n## PCA\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Moderate, though you might find the questions hard.\n\n:::\n\nYou can merge the output of this next step back on to the `rddf` data frame as part of a clustering process, though we'd really want to do some more thinking about what this data *means* and what transformations we'd need to do in order to make them *meaningful*. \n\nFor instance, if we went back to last week's code, we could have appended this InsideAirbnb data *before* doing the dimensionality reduction, or we could apply it now to create a new measure that could be used as a separate part of the clustering process together with the reduced dimensionality of the demographic data. \n\n### Perform Reduction\n\n```python\npcomp = PCA(n_components=???, random_state=42)\nrd    = pcomp.???(pivot_norm)\nprint(f\"The explained variance of each component is: {', '.join([f'{x*100:.2f}%' for x in pcomp.explained_variance_ratio_])}\")\n```\n\nTake the first component and convert to a series to enable the merge:\n\n```python\nairbnb_pca = pd.DataFrame(\n                {'Airbnb Component 1': mms.fit_transform(rd[:,1].reshape(-1,1)).reshape(1,-1)[0]}, \n                index=pivot.index)\n\nairbnb_pca.head()\n```\n\nYou should have something like:\n|       | Airbnb Component 1 |\n| :---- | ----: |\n| **MSOA11CD** |     |\n| **E02000001** | 0.47 |\n| **E02000002** | 0.19 \n\n```python\npcanm = pd.merge(msoas.set_index('MSOA11CD'), airbnb_pca, left_index=True, right_index=True)\npcanm.plot(column='Airbnb Component 1', cmap='viridis', edgecolor='none', legend=True, figsize=(12,8));\n```\n\n### Write to Data Frame\n\n```python\n# Result Set from merge\nrs = pd.merge(rddf, airbnb_pca, left_index=True, right_index=True)\n```\n\nGrab the PCA, UMAP, and Airbnb outputs for clustering and append rescaled price:\n\n```python\n# Merge the reducded dimensionality data frame with the PCA-reduced Airbnb data\n# to create the *cl*uster *d*ata *f*rame\ncldf = pd.merge(rddf.loc[:,'Component 1':], airbnb_pca, \n                left_index=True, right_index=True)\n\n# Append median price from cleaned listings grouped by MSOA too!\ns1 = cleaned.groupby(by='MSOA11CD').price.agg('median')\ncldf['median_price'] = pd.Series(np.squeeze(mms.fit_transform(s1.values.reshape(-1,1))), index=s1.index)\n\n# Append mean price from cleaned listings grouped by MSOA too!\ns2 = cleaned.groupby(by='MSOA11CD').price.agg('mean')\ncldf['mean_price'] = pd.Series(np.squeeze(mms.fit_transform(s2.values.reshape(-1,1))), index=s2.index)\n\ncldf.drop(columns=['Subregion','Borough'], inplace=True)\n\ncldf.head()\n```\n\n### Questions\n\n- Have a think about why you might want to keep the Airbnb data separate from the MSOA data when doing PCA (or any other kind of dimensionality reduction)!\n\n> \n\n- Why *might* it be interesting to add *both* mean and median MSOA prices to the clustering process? Here's a hint (but it's *very* subtle): `sns.jointplot(x=s1, y=s2, s=15, alpha=0.6)`\n\n> \n\n# First K-Means Clustering\n\n## Perform Clustering\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\n```python\nc_nm   = 'KMeans' # Clustering name\nk_pref = ??? # Number of clusters\n\nkmeans = KMeans(n_clusters=k_pref, n_init=25, random_state=42).fit(cldf.drop(columns=['Dimension 1','Dimension 2'])) # The process\n```\n\nHere are the results:\n\n```python\nprint(kmeans.labels_) # The results\n```\n\n## Save Clusters to Data Frame\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\n### Write Series and Assign\n\nNow capture the labels (i.e. clusters) and write them to a data series that we store on the result set df (`rs`):\n\n```python\nrs[c_nm] = pd.Series(kmeans.labels_, index=cldf.index)\n```\n\n### Histogram of Cluster Members\n\nHow are the clusters distributed?\n\n```python\nsns.histplot(data=???, x=c_nm, bins=k_pref);\n```\n\n### Map Clusters\n\nAnd here's a map!\n\n```python\nfig, ax = plt_ldn(water, boros)\nfig.suptitle(f\"{c_nm} Results (k={k_pref})\", fontsize=20, y=0.92)\nrs.plot(column=???, ax=ax, linewidth=0, zorder=0, categorical=???, legend=True);\n```\n\n### Questions\n\n- What critical assumption did we make when running this analysis?\n\n> \n\n- Why did I *not* use the UMAP dimensions here?\n\n> \n\n- Why do we have the `c_nm='kMeans'` when we *know* what kind of clustering we're doing?\n\n> \n\n- Does this look like a *good* clustering?\n\n> \n\n# Second K-Means Clustering\n\n## What's the 'Right' Number of Clusters?\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Moderate.\n\n:::\n\nThere's more than one way to find the 'right' number of clusters. In Singleton's _Geocomputation_ chapter they use WCSS to pick the 'optimal' number of clusters. The idea is that you plot the average WCSS for each number of possible clusters in the range of interest (2...n) and then look for a 'knee' (i.e. kink) in the curve. The principle of this approach is that you look for the point where there is declining benefit from adding more clusters. The problem is that there is always some benefit to adding more clusters (the perfect clustering is k==n), so you don't always see a knee.\n\nAnother way to try to make the process of selecting the number of clusters a little less arbitrary is called the silhouette plot and (like WCSS) it allows us to evaluate the 'quality' of the clustering outcome by examining the distance between each observation and the rest of the cluster. In this case it's based on Partitioning Around the Medoid (PAM).\n\nEither way, to evaluate this in a systematic way, we want to do multiple k-means clusterings for multiple values of k and then we can look at which gives the best results...\n\n```python\nkcldf = cldf.drop(columns=['Dimension 1','Dimension 2'])\n```\n\n### Repeated Clustering\n\nLet's try clustering across a wider range. Because we repeatedly re-run the clustering code (unlike with Hierarchical Clustering) this can take a few minutes. I got nearly 5 minutes on a M2 Mac.\n\n```python\n%%time \n\n# Adapted from: http://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_silhouette_analysis.html\n\nx = []\ny = []\n\n# For resolutions of 'k' in the range 2..40\nfor k in range(2,41):\n    \n    #############\n    # Do the clustering using the main columns\n    kmeans = KMeans(n_clusters=k, n_init=25, random_state=42).fit(kcldf)\n    \n    # Calculate the overall silhouette score\n    silhouette_avg = silhouette_score(kcldf, kmeans.labels_)\n    \n    y.append(k)\n    x.append(silhouette_avg)\n    \n    print('.', end='')\n```\n\n### Plot Silhouette Scores\n\n```python\nprint()\nprint(f\"Largest silhouette score was {max(x):6.4f} for k={y[x.index(max(x))]}\")\n\nplt.plot(y, x)\nplt.gca().xaxis.grid(True);\nplt.gcf().suptitle(\"Average Silhouette Scores\");\n```\n\n::: {.callout-warning}\n\n    **&#9888; Note**: Had we used the UMAP dimensions here you'd likely see more instability in the silhouette plot because the distribution is not remotely Gaussian, though a lot depends on the magnitude of the columns and the number of UMAP vs. PCA components.\n:::\n\nWe can use the largest average silhouette score to determine the 'natural' number of clusters in the data, but that that's only if we don't have any kind of underlying theory, other empirical evidence, or even just a reason for choosing a different value... Again, we're now getting in areas where your judgement and your ability to communicate your rationale to readers is the key thing.\n\n## Final Clustering \n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\nSo although we should probably pick the largest silhouette scores, that's `k=3` which kind of defeats the purpose of clustering in the first place. In the absence of a _compelling_ reason to pick 2 or 3 clusters, let's have a closer look at the _next_ maximum silhouetted score:\n\n### Perform Clustering\n\n```python\nk_pref=???\n\n#############\n# Do the clustering using the main columns\nkmeans = KMeans(n_clusters=k_pref, n_init=25, random_state=42).fit(kcldf)\n\n# Convert to a series\ns = pd.Series(kmeans.labels_, index=kcldf.index, name=c_nm)\n\n# We do this for plotting\nrs[c_nm] = s\n    \n# Calculate the overall silhouette score\nsilhouette_avg = silhouette_score(kcldf, kmeans.labels_)\n\n# Calculate the silhouette values\nsample_silhouette_values = silhouette_samples(kcldf, kmeans.labels_)\n```\n\n### Plot Diagnostics\n\n```python\n#############\n# Create a subplot with 1 row and 2 columns\nfig, (ax1, ax2) = plt.subplots(1, 2)\nfig.set_size_inches(9, 5)\n\n# The 1st subplot is the silhouette plot\n# The silhouette coefficient can range from -1, 1\nax1.set_xlim([-1.0, 1.0]) # Changed from -0.1, 1\n    \n# The (n_clusters+1)*10 is for inserting blank space between silhouette\n# plots of individual clusters, to demarcate them clearly.\nax1.set_ylim([0, kcldf.shape[0] + (k_pref + 1) * 10])\n    \ny_lower = 10\n    \n# For each of the clusters...\nfor i in range(k_pref):\n    # Aggregate the silhouette scores for samples belonging to\n    # cluster i, and sort them\n    ith_cluster_silhouette_values = \\\n        sample_silhouette_values[kmeans.labels_ == i]\n\n    ith_cluster_silhouette_values.sort()\n\n    size_cluster_i = ith_cluster_silhouette_values.shape[0]\n    y_upper = y_lower + size_cluster_i\n        \n    # Set the color ramp\n    color = plt.cm.Spectral(i/k_pref)\n    ax1.fill_betweenx(np.arange(y_lower, y_upper),\n                        0, ith_cluster_silhouette_values,\n                        facecolor=color, edgecolor=color, alpha=0.7)\n\n    # Label the silhouette plots with their cluster numbers at the middle\n    ax1.text(-0.05, y_lower + 0.5 * size_cluster_i, str(i))\n\n    # Compute the new y_lower for next plot\n    y_lower = y_upper + 10  # 10 for the 0 samples\n\n    ax1.set_title(\"The silhouette plot for the clusters.\")\n    ax1.set_xlabel(\"The silhouette coefficient values\")\n    ax1.set_ylabel(\"Cluster label\")\n\n    # The vertical line for average silhouette score of all the values\n    ax1.axvline(x=silhouette_avg, color=\"red\", linestyle=\"--\", linewidth=0.5)\n\n    ax1.set_yticks([])  # Clear the yaxis labels / ticks\n    ax1.set_xticks(np.arange(-1.0, 1.1, 0.2)) # Was: [-0.1, 0, 0.2, 0.4, 0.6, 0.8, 1]\n\n    # 2nd Plot showing the actual clusters formed --\n    # we can only do this for the first two dimensions\n    # so we may not see fully what is causing the \n    # resulting assignment\n    colors = plt.cm.Spectral(kmeans.labels_.astype(float) / k_pref)\n    ax2.scatter(kcldf[kcldf.columns[0]], kcldf[kcldf.columns[1]], \n                marker='.', s=30, lw=0, alpha=0.7, c=colors)\n\n    # Labeling the clusters\n    centers = kmeans.cluster_centers_\n    \n    # Draw white circles at cluster centers\n    ax2.scatter(centers[:, 0], centers[:, 1],\n                marker='o', c=\"white\", alpha=1, s=200)\n\n    for i, c in enumerate(centers):\n        ax2.scatter(c[0], c[1], marker='$%d$' % i, alpha=1, s=50)\n\n    ax2.set_title(\"Visualization of the clustered data\")\n    ax2.set_xlabel(\"Feature space for the 1st feature\")\n    ax2.set_ylabel(\"Feature space for the 2nd feature\")\n\nplt.suptitle((\"Silhouette results for KMeans clustering \"\n                \"with %d clusters\" % k_pref),\n                fontsize=14, fontweight='bold')\n\nplt.show()\n```\n\n::: {.callout-warning}\n\n    **&#9888; Stop**: Make sure that you understand how the silhouette plot and value work, and why your results _may_ diverge from mine.\n::: \n\n### Map Clusters\n\n```python\nfig, ax = plt_ldn(water, boros)\nfig.suptitle(f\"{c_nm} Results (k={k_pref})\", fontsize=20, y=0.92)\nrs.plot(column=c_nm, ax=ax, linewidth=0, zorder=0, categorical=True, legend=True);\n```\n\n## 'Representative' Centroids\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Moderate since, conceptually, there's a lot going on.\n\n:::\n\nTo get a sense of how these clusters differ we can try to extract 'representative' centroids (mid-points of the multi-dimensional cloud that constitutes a cluster). In the case of k-means this will work quite will since the clusters are explicitly built around mean centroids. There's also a k-medoids clustering approach built around the median centroid.\n\nThese are columns that we want to suppress from our sample:\n\n```python\nto_suppress=['OBJECTID', 'BNG_E', 'BNG_N', 'LONG', 'LAT', \n             'Shape__Are', 'Shape__Len', 'geometry', 'Component 1', \n             'Component 2', 'Component 3', 'Component 4', 'Component 5', \n             'Component 6', 'Component 7', 'Dimension 1', 'Dimension 2', \n             'Airbnb Component 1']\n```\n\nTake a sample of the full range of numeric columns:\n\n```python\ncols = random.sample(rs.select_dtypes(exclude='object').drop(columns=to_suppress).columns.to_list(), 12)\nprint(cols)\n```\n\nCalculate the mean of these columns for each cluster:\n\n```python\n# Empty data frame with the columns we'll need\ncentroids = pd.DataFrame(columns=cols)\n\n# For each cluster...\nfor k in sorted(rs[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n    \n    # Select rows where the cluster name matches the cluster number\n    clust = rs[rs[c_nm]==k]\n    \n    # Append the means to the centroids data frame\n    centroids.loc[k] = clust[cols].mean()\n```\n\n```python\ncentroids\n```\n\n```python\ncentroids_long = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    for r in row.index:\n        d = pd.DataFrame({'Variable':r, 'Cluster':i, 'Std. Value':row[r]}, index=[1])\n        centroids_long = pd.concat([centroids_long, d], ignore_index=True)\n```\n\n```python\ng = sns.FacetGrid(centroids_long, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.bar, \"Cluster\", \"Std. Value\")\n```\n\n::: {.callout-note}\n\n    **&#128279; Connections**: The above centroid outputs are a way to think about how each cluster is 'loaded' on to the data. We can't show all of the variables in the data, so we've randomly selected a subset and can then look at how different clusters are more (or less) associated with the standardised value of a particular column/variable.\n:::\n\n# DBSCAN\n\nFor what it's worth, I've had _enormous_ trouble with DBSCAN and this kind of data. I don't think it deals very well with *much* more than three dimensions, so the flexbility to not have to specify the number of clusters is balanced with a density-based approach that is severely hampered by high-dimensional distance-inflation.\n\n```python\n# Drop the PCA dimensions\ncldf2 = cldf.loc[:,'Dimension 1':].copy()\nfor c in [x for x in cldf.columns.to_list() if x.startswith('Dimension ')]:\n    cldf2[c] = pd.Series(np.squeeze(mms.fit_transform(cldf2[c].to_numpy().reshape(-1,1))), index=cldf2.index)\ncldf2.head()\n```\n\n## Work out the Neighbour Distance\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Moderate.\n\n:::\n\nWe normally look for some kind of 'knee' to set the distance.\n\n```python\nnbrs = NearestNeighbors(n_neighbors=6).fit(cldf2)\ndistances, indices = nbrs.kneighbors(cldf2)\n\ndistances = np.sort(distances, axis=0)\ndistances = distances[:,1]\n```\n\n## Derive Approximate Knee\n\n::: {.callout-tip collapse=\"true\"}\n\n#### Difficulty: Low.\n\n:::\n\n```python\nfrom kneed import knee_locator\n\nkn = knee_locator.KneeLocator(np.arange(distances.shape[0]), distances, S=12,\n                              curve='convex', direction='increasing')\nprint(f\"Knee detected at: {kn.knee}\")\nkn.plot_knee()\nkn.plot_knee_normalized()\n```\n\n```python\nprint(f\"Best guess at epsilon for DBSCAN is {distances[kn.knee]:0.4f}\")\n```\n\n## Explore Epsilons\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Moderate.\n\n:::\n\nThere are two values that need to be specified: `eps` and `min_samples`. Both seem to be set largely by trial and error, though we can use the above result as a target. It's easiest to set `min_samples` first since that sets a floor for your cluster size and then `eps` is basically a distance metric that governs how far away something can be from a cluster and still be considered part of that cluster.\n\n### Iterate Over Range\n\n::: {.callout-caution}\n\n    **&#9888; Warning**: Depending on the data volume, this next step may take quite a lot of time since we are iterating through many, many values of Epsilon to explore how the clustering result changes and how well this matches up with (or doesn't) the graph above.\n:::\n\n```python\n%%time \n\nc_nm = 'DBSCAN'\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.4f}'.format(x))\n\nel  = []\n\nmax_clusters  = 10\ncluster_count = 1\n\niters = 0\n\nfor e in np.arange(0.025, 0.76, 0.01): # <- You might want to adjust these!\n    \n    if iters % 25==0: print(f\"{iters} epsilons explored.\") \n    \n    # Run the clustering\n    dbs = DBSCAN(eps=e, min_samples=cldf2.shape[1]+1).fit(cldf2)\n    \n    # See how we did\n    s = pd.Series(dbs.labels_, index=cldf2.index, name=c_nm)\n    \n    row = [e]\n    data = s.value_counts()\n    \n    for c in range(-1, max_clusters+1):\n        try:\n            if np.isnan(data[c]):\n                row.append(None)\n            else: \n                row.append(data[c])\n        except KeyError:\n            row.append(None)\n    \n    el.append(row)\n    iters+=1\n\nedf = pd.DataFrame(el, columns=['Epsilon']+[\"Cluster \" + str(x) for x in list(range(-1,max_clusters+1))])\n\n# Make numeric display a bit neater\npd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))\n\nprint(\"Done.\")\n```\n\n### Examine Clusters\n\n```python\nedf.head() # Notice the -1 cluster for small epsilons\n```\n\n```python\nepsilon_long = pd.DataFrame(columns=['Epsilon','Cluster','Count'])\n\nfor i in range(0,len(edf.index)):\n    row = edf.iloc[i,:]\n    for c in range(1,len(edf.columns.values)):\n        if row[c] != None and not np.isnan(row[c]):\n            d = pd.DataFrame({'Epsilon':row[0], 'Cluster':f\"Cluster {c-2}\", 'Count':row[c]}, index=[1])\n            epsilon_long = pd.concat([epsilon_long, d], ignore_index=True)\n\nepsilon_long['Count'] = epsilon_long.Count.astype(float)\n```\n\n### Plot Cluster Sizes\n\nOne of the really big problems with DBSCAN and this kind of data is that you have no *practical* way of specifying epsilon (whereas if you were doing walkability analysis then you could cluster on walking distance!). So you can look at the data (as above) to get a reasoanble value, but look what the output below shows about the stability of the clusters for different values of epsilon!\n\n```python\nfig, ax = plt.subplots(figsize=(12,8))\nsns.lineplot(data=epsilon_long, x='Epsilon', y='Count', hue='Cluster');\nplt.vlines(x=distances[kn.knee], ymin=0, ymax=epsilon_long.Count.max(), color=(1, .7, .7, .8), linestyles='dashed')\nplt.gcf().suptitle(f\"Cluster sizes for various realisations of Epsilon\");\nplt.tight_layout()\n```\n\n## Final Clustering\n\n::: {.callout-warning collapse=\"true\"}\n\n#### Difficulty: Moderate.\n\n:::\n\n###: Perform Clustering\n\nUse the value from kneed...\n\n```python\ndbs = DBSCAN(eps=distances[kn.knee], min_samples=cldf2.shape[1]+1).fit(cldf2.values)\ns = pd.Series(dbs.labels_, index=cldf2.index, name=c_nm)\nrs[c_nm] = s\nprint(s.value_counts())\n```\n\n###: Map Clusters\n\n```python\nfig, ax = plt_ldn(water, boros)\nfig.suptitle(f\"{c_nm} Results\", fontsize=20, y=0.92)\nrs.plot(column=c_nm, ax=ax, linewidth=0, zorder=0, legend=True, categorical=True);\n```\n\n### 'Representative' Centroids\n\n```python\nto_suppress=['OBJECTID', 'BNG_E', 'BNG_N', 'LONG', 'LAT', \n             'Shape__Are', 'Shape__Len', 'geometry', 'Component 1', \n             'Component 2', 'Component 3', 'Component 4', 'Component 5', \n             'Component 6', 'Component 7', 'Dimension 1', 'Dimension 2', \n             'Airbnb Component 1']\n```\n\nTake a sample of the full range of numeric columns:\n\n```python\ncols = random.sample(rs.select_dtypes(exclude='object').drop(columns=to_suppress).columns.to_list(), 12)\nprint(cols)\n```\n\nCalculate the mean of these columns for each cluster:\n\n```python\n# Empty data frame with the columns we'll need\ncentroids = pd.DataFrame(columns=cols)\n\n# For each cluster...\nfor k in sorted(rs[c_nm].unique()):\n    print(f\"Processing cluster {k}\")\n    \n    # Select rows where the cluster name matches the cluster number\n    clust = rs[rs[c_nm]==k]\n    \n    # Append the means to the centroids data frame\n    centroids.loc[k] = clust[cols].mean()\n```\n\n```python\n# Drop the unclustered records (-1)\ncentroids.drop(labels=[-1], axis=0, inplace=True)\ncentroids\n```\n\n```python\ncentroids_long = pd.DataFrame(columns=['Variable','Cluster','Std. Value'])\nfor i in range(0,len(centroids.index)):\n    row = centroids.iloc[i,:]\n    for r in row.index:\n        d = pd.DataFrame({'Variable':r, 'Cluster':i, 'Std. Value':row[r]}, index=[1])\n        centroids_long = pd.concat([centroids_long, d], ignore_index=True)\n```\n\n```python\ng = sns.FacetGrid(centroids_long, col=\"Variable\", col_wrap=3, height=3, aspect=1.5, margin_titles=True, sharey=True)\ng = g.map(plt.bar, \"Cluster\", \"Std. Value\")\n```\n\n# Self-Organising Maps\n\nSOMs offer a third type of clustering algorithm. They are a relatively 'simple' type of neural network in which the 'map' (of the SOM) adjusts to the data. We're not going to do this in *this* practical, but the main thing is that, unlike the above approaches, SOMs build a 2D map of a higher-dimensional space and use this as a mechanism for subsequently clustering the raw data. In this sense there is a conceptual link between SOMs and PCA or t-SNE or UMAP. Tehy are used quite a lot for text-clustering using keywords (where you have high-dimensionality).\n\nThere are [a lot of SOM implementations in Python](https://www.google.com/search?q=python+self-organizing+map) but the one I used to use, called SOMPY, appears to have [been abandonned](https://github.com/sevamoo/SOMPY/issues).\n\n# Classification\n\nAnd now for something completely different! This is section is **completely optional**, but I thought that you might find it helpful to have a look at how *supervised* learning (classification) differs from *unsupervised* learning (clustering). Here we're going to perform a fairly straightforward classification: predicting the `room_type` for randomly-selected listings. Of course we know the true answer, but this is for demonstration purposes!\n\n## Additional Setup\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty: Hard, as I've left out quite a bit of code.\n\n:::\n\n### Import Libraries\n\n```python\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.inspection import permutation_importance\n```\n\n### Set Up Data\n\nI'm taking a fairly brutal approach here: anything that is not inherently numeric is gone (bye, bye, text), and I'm not bothering to convert implicitly numeric values either: dates could be converted to 'months since last review', for instance, while amenities could be One-Hot Encoded after some pruning of rare amenities. This leaves us with a much smaller number of columns to feed *in* to the classifier.\n\n```python\nprint(f\"Cleaned columns: {', '.join(cleaned.columns.to_list())}.\")\nclassifier_in = cleaned.drop(columns=['listing_url','last_scraped','name','description',\n                                      'host_name', 'host_location', 'property_type', \n                                      'bathrooms_text', 'amenities', 'geometry', 'MSOA11CD',\n                                      'host_since', 'first_review', 'last_review',\n                                      'host_verifications', 'review_scores_rating',\n                                      'reviews_per_month'])\n```\n\n### Remove NAs\n\nNot all classifiers have this issue, but some will struggle to make predictions (or not be able to do so at all) if there are NAs in the data set. The classifier we're using can't deal with NAs, so we have to strip these out, but before we do let's check the effect:\n\n```python\nclassifier_in.isna().sum()\n```\n\nWe can safely drop these now, and you should end up with about 54,000 rows to work with.\n\n```python\nclassifier_in = classifier_in.dropna(axis=0, how='any')\nprint(f\"Now have {classifier_in.shape[0]:,} rows of data to work with (down from {cleaned.shape[0]:,}).\")\n```\n\n```python\nprint()\nprint(f\"Classifier training columns: {', '.join(classifier_in.columns.to_list())}.\")\nclassifier_in.head()\n```\n\n### Remap Non-Numeric Columns\n\nWe do still have a couple of non-numeric columns to deal with: booleans and the thing we're actually trying to predict (the room type)!\n\n```python\nclassifier_in['host_is_superhost'] = classifier_in.host_is_superhost.replace({True:1, False:0}).astype('int')\n```\n\n```python\nle = LabelEncoder()\nclassifier_in['room_class'] = le.fit_transform(classifier_in.room_type)\n```\n\nA quick check: we should only have one type per class and vice versa.\n\n```python\nclassifier_in.groupby(by=['room_type','room_class']).host_id.agg('count').reset_index()\n```\n\n## Random Forest Classification\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty: Hard.\n\n:::\n\nWe're going to use a [Random Forest Classifier](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html) but the nice thing about `sklearn` is that you can quite easily swap in other classifiers if you'd like to explore further. This is one *big* advantage of Python over R in my book: whereas R tends to get new algorithms *first*, they are often implemented independently by many people and you can end up with incompatible data structures that require a lot of faff to reorganise for a different algorithm. Python is a bit more 'managed' and the dominance of `numpy` and `sklearn` and `pandas` means that people have an incentive to contribute to this library or, if it's genuinely novel, to create an implementation that works *like* it would if it were part of `sklearn`!\n\n::: {.callout-note}\n\n    **&#128279; Connections**: So here's an _actual_ Machine Learning implementation, but you'll have seen a lot of parts of the code before! \n:::\n\n### Train/Test Split\n\n```python\ntrain, test = train_test_split(classifier_in, test_size=0.2, random_state=42)\nprint(f\"Train contains {train.shape[0]:,} records.\")\nprint(f\"Test contains {test.shape[0]:,} records.\")\n```\n\n```python\ny_train = train.room_class\nX_train = train.drop(columns=['room_class','room_type'])\n\ny_test  = test.room_class\nX_test  = test.drop(columns=['room_class','room_type'])\n```\n\n### Classifier Setup\n\n```python\nrfc = RandomForestClassifier(\n    max_depth=8,\n    min_samples_split=7,\n    n_jobs=4,\n    random_state=42\n)\n```\n\n### Fit and Predict\n\n```python\nrfc.fit(X_train, y_train)\n```\n\n```python\ny_hat = rfc.predict(X_test)\n```\n\n## Validate\n\n::: {.callout-caution collapse=\"true\"}\n\n#### Difficulty: Hard.\n\n:::\n\n### Confusion Matrix\n\n```python\nc_matrix = pd.DataFrame(confusion_matrix(y_test, y_hat))\nc_matrix.index = le.inverse_transform(c_matrix.index)\nc_matrix.columns = le.inverse_transform(c_matrix.columns)\nc_matrix\n```\n\n### Feature Importance \n\nCompare the Random Forest's built-in 'feature importance' with Permutation Feature Importance as [documented here](https://scikit-learn.org/stable/auto_examples/inspection/plot_permutation_importance.html).\n\n::: {.callout-note}\n\n    **&#128279; Connections**: This next section is the reason you shouldn't blindly run ML algorithms on your data. It turns out that the Random Forest is seriously affected by the scale of different variables, and of binary variables in particular. You will tend to get erroneous feature importance values back from `sklearn`'s RF implementation and should _normally_ look at Permutation Feature Importance values instead. But this little demonstration also shows (above) a more subtle issue: imbalanced data. There are far fewer hotels than there are private rooms, and far fewer of _those_ than there are entire home/apt listings in the sample. So you'll see that the RF has trouble predicting the classes correctly: that's because with a data set like this it's hard to to _better_ than just predicting entire home/apt _Every Single Time_.\n:::\n\n```python\nmdi_importances = pd.Series(\n    rfc.feature_importances_, index=rfc.feature_names_in_\n).sort_values(ascending=True)\n\nax = mdi_importances.plot.barh()\nax.set_title(\"Random Forest Feature Importances (MDI)\")\nax.figure.tight_layout()\n```\n\n### Permutation Feature Importance\n\n```python\nresult = permutation_importance(\n    rfc, X_test, y_test, n_repeats=10, random_state=42, n_jobs=2\n)\n```\n\n```python\nsorted_importances_idx = result.importances_mean.argsort()\nimportances = pd.DataFrame(\n    result.importances[sorted_importances_idx].T,\n    columns=X_test.columns[sorted_importances_idx],\n)\nax = importances.plot.box(vert=False, whis=10)\nax.set_title(\"Permutation Importances (Test Set)\")\nax.axvline(x=0, color=\"k\", linestyle=\"--\")\nax.set_xlabel(\"Decrease in accuracy score\")\nax.figure.tight_layout()\n```\n\n## Shapely Values\n\nShapely values are a big part of [explainable AI](https://shap.readthedocs.io/en/latest/example_notebooks/overviews/An%20introduction%20to%20explainable%20AI%20with%20Shapley%20values.html) and they work (very broadly) by permuting the data to explore how sensitive the predictions made by the model are to the results that you see. For these we need to install two libraries: `shap` (to do the heavy lifting) and `slicer` to deal with the data.\n\n### Install Libraries\n\nWe should now have this already available in Docker, but just in case...\n\n```python\ntry:\n    import shap\nexcept ModuleNotFoundError:\n    ! pip install slicer shap\n    import shap\n```\n\n### Check for Data Types\n\nYou are looking for anything *other* than `int64` or `float64` for the most part. Boolean should be fine, but pandas' internal, nullable integer type will give you a `ufunc` error.\n\n```python\nX_test.info() \n```\n\n```python\nX_test['beds'] = X_test.beds.astype('int')\n```\n\n### Plot Partial Dependence\n\n```python\nshap.partial_dependence_plot(\n    \"price\", rfc.predict, X_test, ice=False,\n    model_expected_value=True, feature_expected_value=True\n)\n```\n\n### Calculate Shapely Values\n\nThis can take a *long* time: 4-5 hours (!!!) without developing a *strategy* for tackling it. See the [long discussion here](https://github.com/slundberg/shap/issues/77). I've taken the approach of subsetting the data substantially (the model is already trained so it won't impact the model's predictions) with a 20% fraction of the test data and an explainer sample of 5%. On my laptop the 'Permutation explainer' stage took about 14 minutes, but your results may obviously be rather different.\n\n```python\nXsample = shap.utils.sample(X_test.sample(frac=0.2, random_state=41), 10)\nexplainer = shap.Explainer(rfc.predict, Xsample)\n```\n\nNow we calculate the shap values for the 5% sample from `X_test`.\n\n::: {.callout-caution}\n\n    **&#9888; Warning**: This next block is the one that takes a long time to run. I got between 3mn and 4mn.\n:::\n\n```python\n%%time\nshap_values = explainer(X_test.sample(frac=.05, random_state=42))\n```\n\n### Single Observation\n\nNow you can take any random record (`sample_ind`) and produce a shap plot to show the role that each attribute played in its classification. Note that getting these plots to save required [some searching on GitHub](https://github.com/slundberg/shap/issues/153).\n\n```python\nsample_ind=250\nshap.plots.waterfall(shap_values[sample_ind], max_display=14, show=False);\nplt.title(f\"Shapely values for observation #{sample_ind} ({X_test.sample(frac=.05, random_state=42).iloc[sample_ind].name})\")\nplt.tight_layout()\n#plt.savefig('practical-09-waterfall.png', dpi=150)\n```\n\n![Shapely Feature Plot for Feature 250](https://github.com/jreades/fsds/raw/master/practicals/img/practical-09-waterfall.png)\n\n### All Observations\n\n```python\nshap.plots.beeswarm(shap_values, show=False)\nplt.title(f\"Shapely Swarm Plot for Sample\")\nplt.tight_layout()\nplt.savefig('practical-09-swarm.png', dpi=150)\n```\n\n![Shapely Swarm Plot](https://github.com/jreades/fsds/raw/master/practicals/img/practical-09-swarm.png)\n\n## Wrap-Up\n\n- Find the appropriate eps value: [Nearest Neighbour Distance Functions](https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Nearest-Neighbor-Distance-Functions) or [Interevent Distance Functions](https://nbviewer.jupyter.org/github/pysal/pointpats/blob/master/notebooks/distance_statistics.ipynb#Interevent-Distance-Functions)\n- [Clustering Points](https://darribas.org/gds_course/content/bH/lab_H.html#clusters-of-points)\n- [Regionalisation algorithms with Aglomerative Clustering](https://darribas.org/gds_course/content/bG/lab_G.html#regionalization-algorithms)\n\nYou've reached the end, you're done... \n\nEr, no. This is barely scratching the surface! I'd suggest that you go back through the above code and do three things:\n1. Add a lot more comments to the code to ensure that really have understood what is going on.\n2. Try playing with some of the parameters (e.g. my thresholds for skew, or non-normality) and seeing how your results change.\n3. Try outputting additional plots that will help you to understand the _quality_ of your clustering results (e.g. what _is_ the makeup of cluster 1? Or 6? What has it picked up? What names would I give these clsuters?).\n\nIf all of that seems like a lot of work then why not learn a bit more about machine learning before calling it a day?\n\nSee: [Introduction to Machine Learning with Scikit-Learn](http://www.slideshare.net/BenjaminBengfort/introduction-to-machine-learning-with-scikitlearn).\n\n",
    "supporting": [
      "Practical-12-Grouping_Data_files"
    ],
    "filters": [],
    "includes": {}
  }
}